<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-05-28 mar. 16:50 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The <code>C</code> programs and their use</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Christophe Pouzat" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">The <code>C</code> programs and their use</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8b2bb98">1. Introduction</a>
<ul>
<li><a href="#org882c590">1.1. Why <code>C</code>, <code>gnuplot</code> and the <code>shell</code>?</a></li>
<li><a href="#org59d9875">1.2. Required software and libraries</a></li>
<li><a href="#org6188cda">1.3. A remark on the code presentation</a></li>
</ul>
</li>
<li><a href="#orgfbb7542">2. Definitions of structures and associated functions holding data</a>
<ul>
<li><a href="#org539cd2b">2.1. <code>ADU</code> data</a>
<ul>
<li><a href="#org1f72b35">2.1.1. Data layout in the <code>HDF5</code> files</a></li>
<li><a href="#orgf508e4d">2.1.2. Data layout in the <code>C</code> code</a>
<ul>
<li><a href="#orgba681dc">2.1.2.1. <code>adu</code> type definition</a></li>
<li><a href="#org4c094dc">2.1.2.2. <code>adu_alloc</code>  definition</a></li>
<li><a href="#orgd6fc093">2.1.2.3. <code>adu_free</code> definition</a></li>
<li><a href="#org5bbcadc">2.1.2.4. <code>adu_get_set</code> macro definitions</a></li>
<li><a href="#org658e433">2.1.2.5. <code>adu_printf</code> definition</a></li>
<li><a href="#orgd18a99b">2.1.2.6. <code>adu_test</code> program definition</a></li>
<li><a href="#orgf2d4f72">2.1.2.7. <code>adu_test</code> compilation, run, etc</a></li>
</ul>
</li>
<li><a href="#org16ae19a">2.1.3. <code>adu</code> header and source</a></li>
</ul>
</li>
<li><a href="#org5d8a1cb">2.2. <code>DATA</code> Group mapping in <code>C</code> code</a>
<ul>
<li><a href="#org14596b7">2.2.1. <code>adu_vector</code>: an array of <code>adu</code> structures</a>
<ul>
<li><a href="#orgf682ccc">2.2.1.1. <code>adu_vector</code> type definition</a></li>
<li><a href="#org858c6c7">2.2.1.2. <code>adu_vector_alloc</code>  definition</a></li>
<li><a href="#orgfbeea49">2.2.1.3. <code>adu_vector_free</code> definition</a></li>
<li><a href="#org84a3b86">2.2.1.4. <code>adu_vector_printf</code> definition</a></li>
<li><a href="#org56191c1">2.2.1.5. <code>data_get_nelt</code></a></li>
<li><a href="#org96317fc">2.2.1.6. <code>adu_vector_read_from_file</code></a></li>
<li><a href="#orga0fee91">2.2.1.7. <code>adu_vector_test</code> program definition</a></li>
<li><a href="#orgca7dd16">2.2.1.8. <code>adu_vector_test</code> compilation, run, etc</a></li>
</ul>
</li>
<li><a href="#orgdc3b6d8">2.2.2. <code>adu_vector</code> header and source</a></li>
</ul>
</li>
<li><a href="#orgd870dce">2.3. <code>DYE</code></a>
<ul>
<li><a href="#org68bedde">2.3.1. DYE parameters in the <code>HDF5</code> files</a></li>
<li><a href="#org3932969">2.3.2. DYE parameters layout in <code>C</code> code</a>
<ul>
<li><a href="#org00c38cc">2.3.2.1. <code>dye</code> type definition</a></li>
<li><a href="#orgcdcdbe3">2.3.2.2. <code>&lt;&lt;dye_read_from_file&gt;&gt;</code></a></li>
<li><a href="#org1236170">2.3.2.3. <code>&lt;&lt;dye_printf&gt;&gt;</code></a></li>
<li><a href="#org9f52ab9">2.3.2.4. <code>dye_test</code></a></li>
<li><a href="#orgac31bd5">2.3.2.5. <code>dye_test</code> compilation, run, etc</a></li>
</ul>
</li>
<li><a href="#orgfb6a259">2.3.3. <code>dye</code> header and source</a></li>
</ul>
</li>
<li><a href="#org59cf272">2.4. <code>ILLUMINATION</code></a>
<ul>
<li><a href="#org5f95a39">2.4.1. <code>ILLUMINATION</code> parameters in the <code>HDF5</code> files</a></li>
<li><a href="#orgfa477b6">2.4.2. <code>ILLUMINATION</code> parameters layout in <code>C</code> code</a>
<ul>
<li><a href="#orgf304249">2.4.2.1. <code>illumination</code> type definition</a></li>
<li><a href="#orgd8a55f5">2.4.2.2. <code>&lt;&lt;illumination_read_from_file&gt;&gt;</code></a></li>
<li><a href="#orge1b125f">2.4.2.3. <code>&lt;&lt;illumination_printf&gt;&gt;</code></a></li>
<li><a href="#org55d25e5">2.4.2.4. <code>illumination_test</code></a></li>
<li><a href="#org7d64476">2.4.2.5. <code>illumination_test</code> compilation, run, etc</a></li>
</ul>
</li>
<li><a href="#org57feea6">2.4.3. <code>illumination</code> header and source</a></li>
</ul>
</li>
<li><a href="#orga77590f">2.5. <code>CCD</code></a>
<ul>
<li><a href="#orgdbaeb36">2.5.1. <code>CCD</code> parameters in the <code>HDF5</code> files</a></li>
<li><a href="#org5042912">2.5.2. <code>CCD</code> parameters layout in <code>C</code> code</a>
<ul>
<li><a href="#org1aec57c">2.5.2.1. <code>ccd</code> type definition</a></li>
<li><a href="#org922808b">2.5.2.2. <code>&lt;&lt;ccd_read_from_file&gt;&gt;</code></a></li>
<li><a href="#org1908d46">2.5.2.3. <code>&lt;&lt;ccd_printf&gt;&gt;</code></a></li>
<li><a href="#org10a6414">2.5.2.4. <code>ccd_test</code></a></li>
<li><a href="#orgf474f23">2.5.2.5. <code>ccd_test</code> compilation, run, etc</a></li>
</ul>
</li>
<li><a href="#orgdfe14dd">2.5.3. <code>ccd</code> header and source</a></li>
</ul>
</li>
<li><a href="#orgbdee825">2.6. Keeping everything in one structure</a>
<ul>
<li><a href="#orgf6a27c5">2.6.1. <code>aba</code> an added buffer approach structure:</a>
<ul>
<li><a href="#org3756893">2.6.1.1. <code>aba</code> type definition</a></li>
<li><a href="#orgabb49c1">2.6.1.2. <code>aba_alloc</code></a></li>
<li><a href="#org16d7b6f">2.6.1.3. <code>aba_free</code></a></li>
<li><a href="#orga50cf78">2.6.1.4. <code>aba_read_from_file</code></a></li>
<li><a href="#org8d433b6">2.6.1.5. <code>aba_printf</code></a></li>
<li><a href="#org24068e0">2.6.1.6. <code>aba_test</code> program definition</a></li>
<li><a href="#org5ac9740">2.6.1.7. <code>aba_test</code> compilation and run</a></li>
</ul>
</li>
<li><a href="#org7982c8e">2.6.2. <code>aba</code> header and source</a></li>
</ul>
</li>
<li><a href="#org1e0a634">2.7. Getting [Fura] estimates</a>
<ul>
<li><a href="#org3c9a42f">2.7.1. <code>time_series</code> structure</a>
<ul>
<li><a href="#org9a727ca">2.7.1.1. <code>ts</code> type definition</a></li>
<li><a href="#org1cdffbc">2.7.1.2. <code>ts_alloc</code></a></li>
<li><a href="#orge8d6bcd">2.7.1.3. <code>ts_free</code></a></li>
<li><a href="#orgf10564b">2.7.1.4. <code>ts_fprintf</code> definition</a></li>
<li><a href="#orgdc020b0">2.7.1.5. <code>ts_vector</code></a></li>
<li><a href="#org5ad2c53">2.7.1.6. <code>ts_vector_alloc</code>  definition</a></li>
<li><a href="#org15d452b">2.7.1.7. <code>ts_vector_free</code> definition</a></li>
<li><a href="#org75b700f">2.7.1.8. <code>ts_vector_fprintf</code> definition</a></li>
</ul>
</li>
<li><a href="#org58cd94d">2.7.2. Getting a [Fura] estimation</a>
<ul>
<li><a href="#orgee1fbc0">2.7.2.1. <code>fura_est</code></a></li>
</ul>
</li>
<li><a href="#org57e10d3">2.7.3. <code>fura</code> header and source</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgba7f560">3. Working the ratiometric estimator</a>
<ul>
<li><a href="#orgee10be2">3.1. Some analytical details</a></li>
<li><a href="#orgac5bb72">3.2. Goodness of fit functions definitions</a>
<ul>
<li><a href="#orgb372213">3.2.1. <code>C</code> code doing the tests</a>
<ul>
<li><a href="#org2958633">3.2.1.1. <code>AndersonDarling_W2</code> definition</a></li>
<li><a href="#org62629f8">3.2.1.2. <code>adinf</code> definition</a></li>
<li><a href="#org18bd7b8">3.2.1.3. <code>AD_cdf_P</code> definition</a></li>
</ul>
</li>
<li><a href="#orgf1b6410">3.2.2. <code>gof</code> header, source and test</a></li>
</ul>
</li>
<li><a href="#org6cbfbf9">3.3. <code>ratio</code> structure and related functions</a>
<ul>
<li><a href="#org3a0bbf1">3.3.1. <code>C</code> code related to <code>ratio</code> structures</a>
<ul>
<li><a href="#org456e0c3">3.3.1.1. <code>ratio</code> type definition</a></li>
<li><a href="#org61d874c">3.3.1.2. <code>ratio_alloc</code>  definition</a></li>
<li><a href="#org75b3062">3.3.1.3. <code>ratio_free</code> definition</a></li>
<li><a href="#org776af6b">3.3.1.4. <code>ratio_get_set</code> macro definitions</a></li>
<li><a href="#org7044468">3.3.1.5. <code>ratio_fprintf</code> definition</a></li>
<li><a href="#orgf748aaa">3.3.1.6. <code>ratio_est</code></a></li>
<li><a href="#orgb4111e9">3.3.1.7. <code>ratio_find_fit_start</code></a></li>
<li><a href="#orgfa63195">3.3.1.8. <code>mono_exp_fit_res</code></a></li>
<li><a href="#org9ce3c85">3.3.1.9. <code>mono_exp_fit_res_fprintf</code></a></li>
<li><a href="#org08f3d43">3.3.1.10. <code>ratio_for_fit</code></a></li>
<li><a href="#org20c7220">3.3.1.11. <code>ratio_residuals</code></a></li>
<li><a href="#org206fc73">3.3.1.12. <code>ratio_fit_callback</code></a></li>
<li><a href="#org3317205">3.3.1.13. <code>ratio_fit</code></a></li>
<li><a href="#org798c77a">3.3.1.14. <code>ratio_test</code></a></li>
<li><a href="#orgabd61fb">3.3.1.15. <code>ratio_test</code> compilation and run</a></li>
</ul>
</li>
<li><a href="#org158204f">3.3.2. <code>ratio</code> header and source</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org90c1bad">4. Building the <code>abaa</code> library</a>
<ul>
<li><a href="#org7546e52">4.1. The <code>abaa.h</code> header file</a></li>
<li><a href="#orge542da2">4.2. The <code>Makefile</code></a>
<ul>
<li><a href="#org0174599">4.2.1. Testing that everything works</a></li>
</ul>
</li>
<li><a href="#orga9bdf37">4.3. The <code>SConstruct</code> file</a></li>
</ul>
</li>
<li><a href="#orgd3e3b9e">5. Our first "user's" program: <code>fit_ratiometric</code></a>
<ul>
<li><a href="#orgb022ce5">5.1. Program's task</a>
<ul>
<li><a href="#org10a85d6">5.1.1. <code>fit_ratiometric</code> code</a>
<ul>
<li><a href="#orgd13b083">5.1.1.1. <code>fit_ratiometric</code> skeleton</a></li>
<li><a href="#org79a8ca2">5.1.1.2. <code>&lt;&lt;fit_ratiometric-usage&gt;&gt;</code></a></li>
<li><a href="#orgf805b91">5.1.1.3. <code>&lt;&lt;fit_ratiometric-args&gt;&gt;</code></a></li>
<li><a href="#org725a6fd">5.1.1.4. <code>&lt;&lt;fit_ratiometric_g_script&gt;&gt;</code></a></li>
<li><a href="#org4a40650">5.1.1.5. <code>fit_ratiometric</code> compilation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org18f26a5">5.2. Using <code>fit_ratiometric</code></a></li>
</ul>
</li>
<li><a href="#org80c75d5">6. Getting Fura concentration during a stimulation: <code>fura_concentration</code></a>
<ul>
<li><a href="#org56afe51">6.1. Motivation</a>
<ul>
<li><a href="#org938dd87">6.1.1. <code>fura_concentration</code> code</a>
<ul>
<li><a href="#orgb44d3d8">6.1.1.1. <code>fura_concentration</code> skeleton</a></li>
<li><a href="#orgb2ac7a5">6.1.1.2. <code>&lt;&lt;fura_concentration-usage&gt;&gt;</code></a></li>
<li><a href="#org1c0bf6a">6.1.1.3. </a></li>
<li><a href="#org42749f0">6.1.1.4. <code>fura_concentration</code> compilation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org30bd292">6.2. Using <code>fura_concentration</code></a></li>
<li><a href="#orgbe7e138">6.3. <code>fura_during_stim</code></a>
<ul>
<li><a href="#orgf865a5e">6.3.1. <code>fura_during_stim</code> code</a>
<ul>
<li><a href="#org7dd6921">6.3.1.1. <code>fura_during_stim</code> skeleton</a></li>
<li><a href="#org09bd5ab">6.3.1.2. <code>&lt;&lt;fura_during_stim-usage&gt;&gt;</code></a></li>
<li><a href="#org548ac8b">6.3.1.3. <code>&lt;&lt;fura_during_stim-args&gt;&gt;</code></a></li>
<li><a href="#orga7cb63d">6.3.1.4. <code>fura_during_stim</code> compilation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1049f33">6.4. Using <code>fura_during_stim</code></a></li>
</ul>
</li>
<li><a href="#org13cbbda">7. Getting the time constant as a function of \(\kappa_{F}\)</a>
<ul>
<li><a href="#org8d510af">7.1. We start by fitting each of the free transients of data set <code>DA_121219_E1.h5</code></a>
<ul>
<li><a href="#org8f71222">7.1.1. First transient</a></li>
<li><a href="#orgb27c43f">7.1.2. Second transient</a></li>
<li><a href="#org89ed8cb">7.1.3. Third transient</a></li>
</ul>
</li>
<li><a href="#orgfc7b5b6">7.2. Plotting \(\tau\) as a function of \(\kappa_F\)</a></li>
</ul>
</li>
<li><a href="#org74a6e6b">8. A program doing all that at once</a>
<ul>
<li><a href="#orgfeaa307">8.1. The <code>aba_ratio</code> program</a>
<ul>
<li><a href="#orgf4e19e1">8.1.1. <code>aba_ratio</code> code</a>
<ul>
<li><a href="#org1b3a380">8.1.1.1. <code>aba_ratio</code> skeleton</a></li>
<li><a href="#org3047dcf">8.1.1.2. <code>&lt;&lt;aba_ratio-usage&gt;&gt;</code></a></li>
<li><a href="#org1eb82fe">8.1.1.3. <code>&lt;&lt;aba_ratio-args&gt;&gt;</code></a></li>
<li><a href="#orgdcca341">8.1.1.4. <code>&lt;&lt;aba_ratio-read-data&gt;&gt;</code></a></li>
<li><a href="#orgce4031c">8.1.1.5. <code>&lt;&lt;aba_ratio-get-loading-curve&gt;&gt;</code></a></li>
<li><a href="#org3b6e375">8.1.1.6. <code>&lt;&lt;aba_ratio_loading_curve_g_script&gt;&gt;</code></a></li>
<li><a href="#org2d9cd87">8.1.1.7. <code>&lt;&lt;aba_ratio_ratiometric_estimator&gt;&gt;</code></a></li>
<li><a href="#org014763c">8.1.1.8. <code>&lt;&lt;aba_ratio_mono_exp_fit&gt;&gt;</code></a></li>
<li><a href="#org2994563">8.1.1.9. <code>&lt;&lt;aba_ratio_mono_exp_g_script&gt;&gt;</code></a></li>
<li><a href="#org7320514">8.1.1.10. <code>&lt;&lt;aba_ratio_kappa_Fura&gt;&gt;</code></a></li>
<li><a href="#org92706dc">8.1.1.11. <code>&lt;&lt;aba_ratio_tau_vs_kappa&gt;&gt;</code></a></li>
<li><a href="#orgf34f080">8.1.1.12. <code>&lt;&lt;aba_ratio_tau_vs_kappa_g_script&gt;&gt;</code></a></li>
<li><a href="#org095766c">8.1.1.13. <code>&lt;&lt;wls_fit&gt;&gt;</code></a></li>
<li><a href="#orgda4391b">8.1.1.14. <code>&lt;&lt;robust_fit&gt;&gt;</code></a></li>
<li><a href="#org650a3f2">8.1.1.15. <code>aba_ratio</code> compilation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org42e3831">8.2. Using <code>aba_ratio</code></a>
<ul>
<li><a href="#orgbf804fc">8.2.1. Getting help</a></li>
<li><a href="#org45f85d5">8.2.2. Running <code>aba_ratio</code></a></li>
<li><a href="#org36e811a">8.2.3. Looking at the results</a>
<ul>
<li><a href="#orgc573e75">8.2.3.1. loading curve</a></li>
<li><a href="#org6d9666c">8.2.3.2. First stimulation fit</a></li>
<li><a href="#org4bd5839">8.2.3.3. Second stimulation fit</a></li>
<li><a href="#org22ff036">8.2.3.4. Third stimulation fit</a></li>
<li><a href="#org8586505">8.2.3.5. \(\tau\) vs \(\kappa_{Fura}\) regression</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org8b2bb98" class="outline-2">
<h2 id="org8b2bb98"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
We define in this document the <code>C</code> codes / programs developped for the analysis of the "\(\beta\) ecsin" data with the added buffer approach. Examples of use are also included.
</p>
</div>

<div id="outline-container-org882c590" class="outline-3">
<h3 id="org882c590"><span class="section-number-3">1.1</span> Why <code>C</code>, <code>gnuplot</code> and the <code>shell</code>?</h3>
<div class="outline-text-3" id="text-1-1">
<p>
This document is the exploration of an idea: use the shell (<code>bash</code> or <code>zsh</code>) instead of the <code>Python</code> or <code>R</code> command line for interactive analysis and write the short functions performing the actual analysis in <code>C</code>. The motivation for this exploration comes from two books by Ben Klemens: <a href="http://modelingwithdata.org/about_the_book.html">Modeling With Data</a> and <i>21st Century C</i>. The main advantages of <code>C</code> compared to the other two languages are:
</p>
<ul class="org-ul">
<li>Its stability (the programs written here are very likely to run unchanged in 20 years from now; what can be sure that this won't be true with <code>Python</code>).</li>
<li>The development tools that come with it are just spectacular (see the very short and very clear book of Brian Gough <a href="http://www.network-theory.co.uk/docs/gccintro/">An Introduction to GCC</a> to understand what I mean by that).</li>
</ul>
</div>
</div>

<div id="outline-container-org59d9875" class="outline-3">
<h3 id="org59d9875"><span class="section-number-3">1.2</span> Required software and libraries</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Since a <a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">Bash</a> or a <a href="https://en.wikipedia.org/wiki/Z_shell">Z shell</a> are going to be used, <code>Windows</code> users will have to install <a href="https://cygwin.com/index.html">Cygwin</a>, <code>Linux</code> and <code>MacOS</code> users should have the <code>bash</code> shell by default and the <code>zsh</code> shell readily available from their package manager. To dig deeper into the amazing possibilities (and spectacular editorial support) of these tools, check <a href="http://www.bash2zsh.com/">From Bash to Z Shell. Conquering the Command Line</a> by Kiddle, Peek and Stephenson.
</p>

<p>
The no-shell codes are going to be written in <code>C</code>, meaning that a <code>C</code> compiler together with the "classical" development tools (<code>make</code>, etc) are required. I'm going to use <a href="https://gcc.gnu.org/"><code>gcc</code></a> here.
</p>

<p>
The heavy computational work is going to be performed mainly by the <a href="http://www.gnu.org/software/gsl/">gsl</a> (the <i>GNU Scientific Library</i>) that is easily installed through your package manager (from now one, for windows users, the "package manager" refers to the one of <code>Cygwin</code>). The graphs are be generated with <a href="http://www.gnuplot.info/">gnuplot</a>; for a quick tutorial check <a href="http://physicspmb.ukzn.ac.za/index.php/Gnuplot_tutorial">http://physicspmb.ukzn.ac.za/index.php/Gnuplot_tutorial</a>, for an easy to navigate set of (sophisticated) recipes check <a href="http://www.gnuplotting.org/">http://www.gnuplotting.org/</a>. The data sets are in <a href="https://www.hdfgroup.org/HDF5/">HDF5</a> format and the <code>C</code> library, as well as the command line tools, developed by the HDF5 group are going to be heavily used here. 
</p>
</div>
</div>

<div id="outline-container-org6188cda" class="outline-3">
<h3 id="org6188cda"><span class="section-number-3">1.3</span> A remark on the code presentation</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The <a href="https://en.wikipedia.org/wiki/Literate_programming">literate programming</a> approach is used here. This means that the code is broken into "manageable" pieces that are individually explained (when just reading the code is not enough), they are then pasted together to give the code that will actually get compiled. These manageable pieces are called blocks and each block gets a name like: <code>&lt;&lt;name-of-the-block&gt;&gt;</code> upon definition. It is then referred to by this name when used in subsequent codes. See Schulte, Davison, Dye and Dominik (2010) <a href="https://www.jstatsoft.org/article/view/v046i03">A Multi-Language Computing Environment for Literate Programming and Reproducible Research </a>for further explanations. The code blocks also include documentation in <a href="http://www.stack.nl/~dimitri/doxygen/index.html">Doxygen</a> format and we try to avoid writing twice the same thing, in the text and in the documentation. So if something is "missing" from the text description, please check the documentation within the block first to see if what you're looking for is there.
</p>
</div>
</div>
</div>

<div id="outline-container-orgfbb7542" class="outline-2">
<h2 id="orgfbb7542"><span class="section-number-2">2</span> Definitions of structures and associated functions holding data</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org539cd2b" class="outline-3">
<h3 id="org539cd2b"><span class="section-number-3">2.1</span> <code>ADU</code> data</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-org1f72b35" class="outline-4">
<h4 id="org1f72b35"><span class="section-number-4">2.1.1</span> Data layout in the <code>HDF5</code> files</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
Our data stored in <code>HDF5</code> format contain the actual <code>ADU</code> recordings in Groups called <code>DATA</code>. Each of those groups contains three datasets:
</p>

<dl class="org-dl">
<dt><code>ADU</code></dt><dd>an array of integers with 7 columns and as many rows as there were measurements. The first column is the <code>time_index</code> column, the second contains the <code>ADU340</code> measurements (measurements at 340 nm in the ROI), then comes the <code>ADU340B</code> measurements (measurements at 340 nm in the ROB), the <code>ADU360</code> measurements (at 360 nm in the ROI), the <code>ADU360B</code> measurements (at 360 nm in the ROB), the <code>ADU380</code> measurements (at 380 nm in the ROI), the <code>ADU380B</code> measurements (at 380 nm in the ROB).</dd>
<dt><code>TIME_DELTA</code></dt><dd>a scalar (see below).</dd>
<dt><code>TIME_OFFSET</code></dt><dd>a scalar (see below).</dd>
</dl>

<p>
To get the real time of each measurement, multiply the first column of <code>ADU</code> by <code>TIME_DELTA</code> and add <code>TIME_OFFSET</code>. The other columns of the <code>ADU</code> matrix contain the "raw" readings of the <code>P</code> of <code>P_B</code> pixels from the CCD chip.
</p>
</div>
</div>

<div id="outline-container-orgf508e4d" class="outline-4">
<h4 id="orgf508e4d"><span class="section-number-4">2.1.2</span> Data layout in the <code>C</code> code</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
We will store these data in <code>double</code> format in a new type of structure called <code>adu</code>. Each of the seven column will become a single pointer to a <a href="https://www.gnu.org/software/gsl/manual/html_node/Vectors.html#Vectors"><code>gsl_vector</code></a>. We define this structure in a specific code block in the next section.
</p>
</div>

<div id="outline-container-orgba681dc" class="outline-5">
<h5 id="orgba681dc"><span class="section-number-5">2.1.2.1</span> <code>adu</code> type definition</h5>
<div class="outline-text-5" id="text-2-1-2-1">
<div class="org-src-container">
<pre class="src src-C" id="org07829d3">/** @brief Structure holding arrays of gsl_vectors each vector contains
 *         ADU measurements from at a specific wavelength from a 
 *         specific loaction (ROI or ROB).
*/
typedef struct
{
  gsl_vector * ADU340; //!&lt; measurements at 340 nm from ROI
  gsl_vector * ADU340B; //!&lt; measurements at 340 nm from ROB
  gsl_vector * ADU360; //!&lt; measurements at 360 nm from ROI
  gsl_vector * ADU360B; //!&lt; measurements at 360 nm from ROB
  gsl_vector * ADU380; //!&lt; measurements at 380 nm from ROI
  gsl_vector * ADU380B; //!&lt; measurements at 380 nm from ROB
  gsl_vector * TIME; //!&lt; time (in s) of measurements
} adu;
</pre>
</div>
</div>
</div>

<div id="outline-container-org4c094dc" class="outline-5">
<h5 id="org4c094dc"><span class="section-number-5">2.1.2.2</span> <code>adu_alloc</code>  definition</h5>
<div class="outline-text-5" id="text-2-1-2-2">
<p>
It will be helpful to have an <code>alloc</code> function for <code>adu</code> structures:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org7972880">/** @brief Allocates an [adu](@ref adu)
 *
 *  The function allocates memory for an [adu](@ref adu) structure
 *
 *  @param[in] n_obs the number of measurements / obserations 
 *  @returns a pointer to an allocated [adu](@ref adu)
*/
adu * adu_alloc(size_t n_obs) {
  adu * res = malloc(sizeof(adu));
  res-&gt;ADU340 = gsl_vector_alloc(n_obs);
  res-&gt;ADU340B = gsl_vector_alloc(n_obs);
  res-&gt;ADU360 = gsl_vector_alloc(n_obs);
  res-&gt;ADU360B = gsl_vector_alloc(n_obs);
  res-&gt;ADU380 = gsl_vector_alloc(n_obs);
  res-&gt;ADU380B = gsl_vector_alloc(n_obs);
  res-&gt;TIME = gsl_vector_alloc(n_obs);
  return res;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd6fc093" class="outline-5">
<h5 id="orgd6fc093"><span class="section-number-5">2.1.2.3</span> <code>adu_free</code> definition</h5>
<div class="outline-text-5" id="text-2-1-2-3">
<p>
It will also be helpful to have a <code>free</code> function for <code>adu</code> structures:
</p>
<div class="org-src-container">
<pre class="src src-C" id="org087c398">/** @brief Frees an [adu](@ref adu)
 
    @param[in,out] adu_ptr a pointer to an allocated [adu](@ref adu) structure
    @returns 0 if everything goes fine 
*/
int adu_free(adu * adu_ptr) {
  gsl_vector_free(adu_ptr-&gt;ADU340);
  gsl_vector_free(adu_ptr-&gt;ADU340B);
  gsl_vector_free(adu_ptr-&gt;ADU360);
  gsl_vector_free(adu_ptr-&gt;ADU360B);
  gsl_vector_free(adu_ptr-&gt;ADU380);
  gsl_vector_free(adu_ptr-&gt;ADU380B);
  gsl_vector_free(adu_ptr-&gt;TIME);
  free(adu_ptr);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org5bbcadc" class="outline-5">
<h5 id="org5bbcadc"><span class="section-number-5">2.1.2.4</span> <code>adu_get_set</code> macro definitions</h5>
<div class="outline-text-5" id="text-2-1-2-4">
<p>
We define next <code>macros</code> with arguments giving an easy way to get and set values of specific members of <code>adu</code> structure:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org9bf8906">/** @def adu_get(adu,member,i)
 *  @brief A macro that returns value at index \a i of
 *         member \a member from \a adu structure 
 */
#define adu_get(adu,member,i) gsl_vector_get(adu-&gt;member,i)
/** @def adu_set(adu,member,i,x)
 *  @brief A macro that sets value at index \a i of
 *         member \a member from \a adu structure at \a x 
 */
#define adu_set(adu,member,i,x) gsl_vector_set(adu-&gt;member,i,x)
</pre>
</div>
</div>
</div>

<div id="outline-container-org658e433" class="outline-5">
<h5 id="org658e433"><span class="section-number-5">2.1.2.5</span> <code>adu_printf</code> definition</h5>
<div class="outline-text-5" id="text-2-1-2-5">
<p>
We now define a function that prints to the <code>stdout</code> the content of an <code>adu</code> structure:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org93de697">/** @brief Prints [adu](@ref adu) content to stdout
 
    @param[in] padu a pointer to an [adu](@ref adu) structure
    @return 0 if everything goes fine
 */
int adu_printf(adu * padu) {
  size_t nobs=(padu)-&gt;TIME-&gt;size;
  printf("#    Time   ADU340  ADU340B   ADU360  ADU360B   ADU380  ADU380B\n");
  for (size_t i=0; i&lt;nobs; i++) {
    printf("%9.9g %8d %8d %8d %8d %8d %8d\n",
	   adu_get((padu),TIME,i),
	   (int) adu_get(padu,ADU340,i),
	   (int) adu_get(padu,ADU340B,i),
	   (int) adu_get(padu,ADU360,i),
	   (int) adu_get(padu,ADU360B,i),
	   (int) adu_get(padu,ADU380,i),
	   (int) adu_get(padu,ADU380B,i));
  }
  printf("\n\n");
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd18a99b" class="outline-5">
<h5 id="orgd18a99b"><span class="section-number-5">2.1.2.6</span> <code>adu_test</code> program definition</h5>
<div class="outline-text-5" id="text-2-1-2-6">
<p>
We now define a short program <code>adu_test</code> allowing us to test the functions we just defined. We store this program is a sub-directory called <code>code</code>.
</p>

<div class="org-src-container">
<pre class="src src-C" id="org6743135">/** @file adu_test.c
 *  @brief Test program for adu structure and related
 *         functions.
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;gsl/gsl_vector.h&gt;
&lt;&lt;adu-type-definition&gt;&gt;
&lt;&lt;adu_alloc&gt;&gt;
&lt;&lt;adu_free&gt;&gt;
&lt;&lt;adu_get_set&gt;&gt;
&lt;&lt;adu_printf&gt;&gt;
int main()
{
  // Allocate an adu with 2 observations
  adu * adu_ptr = adu_alloc(2);
  printf("Allocated adu_ptr with two elements.\n");
  printf("Setting values of ADU340 field.\n");
  adu_set(adu_ptr,ADU340,0,1.0);
  adu_set(adu_ptr,ADU340,1,2.0);
  printf("Setting values of ADU340B field.\n");
  adu_set(adu_ptr,ADU340B,0,3.0);
  adu_set(adu_ptr,ADU340B,1,4.0);
  printf("Setting values of ADU360 field.\n");
  adu_set(adu_ptr,ADU360,0,5.0);
  adu_set(adu_ptr,ADU360,1,6.0);
  printf("Setting values of ADU360B field.\n");
  adu_set(adu_ptr,ADU360B,0,7.0);
  adu_set(adu_ptr,ADU360B,1,8.0);
  printf("Setting values of ADU380 field.\n");
  adu_set(adu_ptr,ADU380,0,9.0);
  adu_set(adu_ptr,ADU380,1,10.0);
  printf("Setting values of ADU380B field.\n");
  adu_set(adu_ptr,ADU380B,0,11.0);
  adu_set(adu_ptr,ADU380B,1,12.0);
  printf("Setting values of TIME field.\n");
  adu_set(adu_ptr,TIME,0,1.5);
  adu_set(adu_ptr,TIME,1,2.5);
  printf("The content of the structure is.\n");
  adu_printf(adu_ptr);
  // free allocated adu
  adu_free(adu_ptr);
  printf("Freed adu_ptr. Don't forget running valgrind!\n");
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf2d4f72" class="outline-5">
<h5 id="orgf2d4f72"><span class="section-number-5">2.1.2.7</span> <code>adu_test</code> compilation, run, etc</h5>
<div class="outline-text-5" id="text-2-1-2-7">
<p>
We compile the code with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orge099712">gcc -Wall -g -o code/adu_test code/adu_test.c -lgsl -lgslcblas -lm -std=gnu11
</pre>
</div>

<p>
We run it with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org6d887b0">./code/adu_test
</pre>
</div>

<pre class="example">
Allocated adu_ptr with two elements.
Setting values of ADU340 field.
Setting values of ADU340B field.
Setting values of ADU360 field.
Setting values of ADU360B field.
Setting values of ADU380 field.
Setting values of ADU380B field.
Setting values of TIME field.
The content of the structure is.
#    Time   ADU340  ADU340B   ADU360  ADU360B   ADU380  ADU380B
      1.5        1        3        5        7        9       11
      2.5        2        4        6        8       10       12


Freed adu_ptr. Don't forget running valgrind!
</pre>


<p>
We run it with <a href="http://valgrind.org/">Valgrind</a> to make sure that all the allocated memory has been freed upon program termination:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orga35ef75">valgrind ./code/adu_test
</pre>
</div>

<pre class="example">
==14941== Memcheck, a memory error detector
==14941== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==14941== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info
==14941== Command: ./code/adu_test
==14941== 
Allocated adu_ptr with two elements.
Setting values of ADU340 field.
Setting values of ADU340B field.
Setting values of ADU360 field.
Setting values of ADU360B field.
Setting values of ADU380 field.
Setting values of ADU380B field.
Setting values of TIME field.
The content of the structure is.
#    Time   ADU340  ADU340B   ADU360  ADU360B   ADU380  ADU380B
      1.5        1        3        5        7        9       11
      2.5        2        4        6        8       10       12


Freed adu_ptr. Don't forget running valgrind!
==14941== 
==14941== HEAP SUMMARY:
==14941==     in use at exit: 0 bytes in 0 blocks
==14941==   total heap usage: 23 allocs, 23 frees, 4,656 bytes allocated
==14941== 
==14941== All heap blocks were freed -- no leaks are possible
==14941== 
==14941== For counts of detected and suppressed errors, rerun with: -v
==14941== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>


<p>
We are happy!
</p>
</div>
</div>
</div>

<div id="outline-container-org16ae19a" class="outline-4">
<h4 id="org16ae19a"><span class="section-number-4">2.1.3</span> <code>adu</code> header and source</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
We define two code blocks for later use when we will define a library. Code block <code>&lt;&lt;adu.h&gt;&gt;</code> contains the types, macros and function prototypes we just defined. 
</p>

<div class="org-src-container">
<pre class="src src-C" id="org57aefaf">&lt;&lt;adu-type-definition&gt;&gt;

adu * adu_alloc(size_t n_obs);
int adu_free(adu * adu_ptr);
&lt;&lt;adu_get_set&gt;&gt;
int adu_printf(adu * padu);
</pre>
</div>

<p>
Code block <code>&lt;&lt;adu.c&gt;&gt;</code> contains the function definitions <i>per se</i> and gets stored in file <code>code/adu.c</code>: 
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgb8cabae">/** \file adu.c
    \brief Definitions of functions related to [adu](@ref adu) structures
 */
#include "abaa.h"
&lt;&lt;adu_alloc&gt;&gt;
&lt;&lt;adu_free&gt;&gt;
&lt;&lt;adu_printf&gt;&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5d8a1cb" class="outline-3">
<h3 id="org5d8a1cb"><span class="section-number-3">2.2</span> <code>DATA</code> Group mapping in <code>C</code> code</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-org14596b7" class="outline-4">
<h4 id="org14596b7"><span class="section-number-4">2.2.1</span> <code>adu_vector</code>: an array of <code>adu</code> structures</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
We will create a data type called <code>adu_vector</code> holding an array whose successive elements will be <code>adu</code> structures. Element 0 of our array will contain the <code>load</code> dataset and the following elements will contain the <code>stim1</code>, <code>stim2</code>, etc. datasets.
</p>
</div>

<div id="outline-container-orgf682ccc" class="outline-5">
<h5 id="orgf682ccc"><span class="section-number-5">2.2.1.1</span> <code>adu_vector</code> type definition</h5>
<div class="outline-text-5" id="text-2-2-1-1">
<div class="org-src-container">
<pre class="src src-C" id="org00492d6">/** @brief Structure holding arrays of `adu` structures .
*/
typedef struct
{
  size_t nelt; //!&lt; number of elements in the vector
  adu ** adu_v; //!&lt; array of pointers to adu structures
} adu_vector;
</pre>
</div>
</div>
</div>

<div id="outline-container-org858c6c7" class="outline-5">
<h5 id="org858c6c7"><span class="section-number-5">2.2.1.2</span> <code>adu_vector_alloc</code>  definition</h5>
<div class="outline-text-5" id="text-2-2-1-2">
<p>
It will be helpful to have an <code>alloc</code> function for <code>adu_vector</code> structures:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org7c3a6f5">/** @brief Allocates an adu_vector
 *
 *  The function allocates memory for an adu_vector structure
 *
 *  @param[in] nelt the number of stimulation 
 *  @returns a pointer to an allocated adu_vector
*/
adu_vector * adu_vector_alloc(size_t nelt) {
  adu_vector * res = malloc(sizeof(adu_vector));
  res-&gt;nelt = nelt;
  res-&gt;adu_v = malloc(nelt*sizeof(adu));
  return res;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfbeea49" class="outline-5">
<h5 id="orgfbeea49"><span class="section-number-5">2.2.1.3</span> <code>adu_vector_free</code> definition</h5>
<div class="outline-text-5" id="text-2-2-1-3">
<p>
It will also be helpful to have a <code>free</code> function for <code>adu_vector</code> structures:
</p>
<div class="org-src-container">
<pre class="src src-C" id="org8954ec6">/** @brief Frees an adu_vector
 *
 *  @param[in,out] adu_vector_ptr a pointer to an allocated adu_vector structure
 *  @returns 0 if everything goes fine 
*/
int adu_vector_free(adu_vector * adu_vector_ptr) {
  for (size_t d_idx=0; d_idx&lt;adu_vector_ptr-&gt;nelt; d_idx++) 
    adu_free(adu_vector_ptr-&gt;adu_v[d_idx]);
  free(adu_vector_ptr-&gt;adu_v);
  free(adu_vector_ptr);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org84a3b86" class="outline-5">
<h5 id="org84a3b86"><span class="section-number-5">2.2.1.4</span> <code>adu_vector_printf</code> definition</h5>
<div class="outline-text-5" id="text-2-2-1-4">
<p>
We now define a function that prints to the <code>stdout</code> the content of an <code>adu_vector</code> structure:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org926dd94">/** @brief Prints adu_vector content to stdout
 *
 *  @param[in] padu_vector a pointer to an adu_vector structure
 *  @return 0 if everything goes fine
 */
int adu_vector_printf(adu_vector * padu_vector) {
  for (size_t d_idx=0; d_idx&lt;padu_vector-&gt;nelt; d_idx++) {
    size_t nobs=(padu_vector-&gt;adu_v[d_idx])-&gt;TIME-&gt;size;
    if (d_idx == 0) {
      printf("# Loading curve with %d elements\n", (int) nobs);
    } else {
      printf("# Stim %d with %d elements\n", (int) d_idx, (int) nobs);
    }
    adu_printf(padu_vector-&gt;adu_v[d_idx]);
  }
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org56191c1" class="outline-5">
<h5 id="org56191c1"><span class="section-number-5">2.2.1.5</span> <code>data_get_nelt</code></h5>
<div class="outline-text-5" id="text-2-2-1-5">
<div class="org-src-container">
<pre class="src src-C" id="org31ce0dc">/** @brief Returns number of DataSets in Group DATA
 *
 *  The number returned equal 1 plus the number of stim
 *
 *  @param[in] file_id an HFD5 file identifier
 *  @return a size_t, the number of DataSets 
 */
size_t data_get_nelt(hid_t file_id) {
  char dset[] = "/DATA";
  hid_t gid = H5Gopen(file_id,dset,H5P_DEFAULT);
  // Get info on group DATA
  H5G_info_t group_info;
  H5Gget_info(gid, &amp;group_info);
  size_t n_elt = (size_t) group_info.nlinks;
  // Close Group
  H5Gclose(gid);
  return n_elt;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org96317fc" class="outline-5">
<h5 id="org96317fc"><span class="section-number-5">2.2.1.6</span> <code>adu_vector_read_from_file</code></h5>
<div class="outline-text-5" id="text-2-2-1-6">
<div class="org-src-container">
<pre class="src src-C" id="org456fa67">/** @brief Allocates and initializes an `adu_vector` structure
 *         read from Group DATA in a file
 *
 *  @param[in] file_id HDF5 file identifier
 *  @return an allocated and initialized pointer to an adu_vector structure
 */
adu_vector * adu_vector_read_from_file(hid_t file_id) {
  char *dsets[] = {"/DATA/load","/DATA/stim1","/DATA/stim2",
		   "/DATA/stim3","/DATA/stim4","/DATA/stim5",
		   "/DATA/stim6","/DATA/stim7","/DATA/stim8"};
  char STIM[256],DELTA[256],OFFSET[256];
  size_t n_elt = data_get_nelt(file_id);
  if (n_elt &gt; 9) {
    fprintf(stderr,"Too many data sets (&gt;9).\n");
    return NULL;
  }
  adu_vector * data = adu_vector_alloc(n_elt);
  for (size_t d_idx=0; d_idx&lt;n_elt; d_idx++) { 
    STIM[0] = '\0';
    strcat(STIM,dsets[d_idx]);
    strcat(STIM,"/ADU");
    // load DataSet
    hsize_t dims[2];
    H5LTget_dataset_info(file_id,STIM,dims,NULL,NULL);
    size_t nobs = (size_t) dims[0];
    size_t ncol = (size_t) dims[1];
    int *ADU = malloc(nobs*ncol*sizeof(int));
    H5LTread_dataset_int(file_id,STIM,ADU);
    DELTA[0] = '\0';
    strcat(DELTA,dsets[d_idx]);
    strcat(DELTA,"/TIME_DELTA");
    double delta;
    H5LTread_dataset_double(file_id,DELTA,&amp;delta);
    OFFSET[0] = '\0';
    strcat(OFFSET,dsets[d_idx]);
    strcat(OFFSET,"/TIME_OFFSET");
    double offset;
    H5LTread_dataset_double(file_id,OFFSET,&amp;offset);
    data-&gt;adu_v[d_idx] = adu_alloc(nobs);
    for (size_t i=0; i&lt;nobs; i++) {
      adu_set((data-&gt;adu_v[d_idx]),TIME,i,offset+delta*((double) ADU[i*ncol]));
      adu_set((data-&gt;adu_v[d_idx]),ADU340,i,(double) ADU[i*ncol + 1]);
      adu_set((data-&gt;adu_v[d_idx]),ADU340B,i,(double) ADU[i*ncol + 2]);
      adu_set((data-&gt;adu_v[d_idx]),ADU360,i,(double) ADU[i*ncol + 3]);
      adu_set((data-&gt;adu_v[d_idx]),ADU360B,i,(double) ADU[i*ncol + 4]);
      adu_set((data-&gt;adu_v[d_idx]),ADU380,i,(double) ADU[i*ncol + 5]);
      adu_set((data-&gt;adu_v[d_idx]),ADU380B,i,(double) ADU[i*ncol + 6]);
    }
    free(ADU);
  }
  return data;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga0fee91" class="outline-5">
<h5 id="orga0fee91"><span class="section-number-5">2.2.1.7</span> <code>adu_vector_test</code> program definition</h5>
<div class="outline-text-5" id="text-2-2-1-7">
<p>
The only "difficulty" in that code is the part that deals with opening / closing <code>HDF5</code> files and <code>Groups</code> (within) those files.
</p>
<div class="org-src-container">
<pre class="src src-C" id="org0939c5b">/** @file adu_vector_test.c
 *  @brief test functions reading ADU data from an HDF5 file
 *         and printing them to the stdout 
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;hdf5.h&gt;
#include &lt;hdf5_hl.h&gt;
#include &lt;gsl/gsl_vector.h&gt;
&lt;&lt;adu-type-definition&gt;&gt;
&lt;&lt;adu_alloc&gt;&gt;
&lt;&lt;adu_free&gt;&gt;
&lt;&lt;adu_get_set&gt;&gt;
&lt;&lt;adu_vector-type-definition&gt;&gt;
&lt;&lt;adu_vector_alloc&gt;&gt;
&lt;&lt;adu_vector_free&gt;&gt;
&lt;&lt;data_get_nelt&gt;&gt;
&lt;&lt;adu_vector_read_from_file&gt;&gt;
&lt;&lt;adu_printf&gt;&gt;
&lt;&lt;adu_vector_printf&gt;&gt;
#define FNAME "data_paper/data_beta_escin/DA_121219_E1.h5"
int main()
{
  // Open FILE
  char fname[] = FNAME;
  hid_t fid = H5Fopen (fname, H5F_ACC_RDONLY, H5P_DEFAULT);
  adu_vector * data = adu_vector_read_from_file(fid);    
  // Close file
  H5Fclose (fid);
  if (data == NULL) return -1;
  adu_vector_printf(data);
  adu_vector_free(data);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgca7dd16" class="outline-5">
<h5 id="orgca7dd16"><span class="section-number-5">2.2.1.8</span> <code>adu_vector_test</code> compilation, run, etc</h5>
<div class="outline-text-5" id="text-2-2-1-8">
<p>
We compile the code with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgb318339">gcc -Wall -g -o code/adu_vector_test code/adu_vector_test.c -lgsl -lgslcblas -lhdf5 -lhdf5_hl -lm -std=gnu11
</pre>
</div>

<p>
We test and "valgrind" it with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org92202f6">valgrind ./code/adu_vector_test &gt; toto
</pre>
</div>

<pre class="example">
==14949== Memcheck, a memory error detector
==14949== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==14949== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info
==14949== Command: ./code/adu_vector_test
==14949== 
==14949== 
==14949== HEAP SUMMARY:
==14949==     in use at exit: 0 bytes in 0 blocks
==14949==   total heap usage: 3,964 allocs, 3,964 frees, 1,666,868 bytes allocated
==14949== 
==14949== All heap blocks were freed -- no leaks are possible
==14949== 
==14949== For counts of detected and suppressed errors, rerun with: -v
==14949== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>


<p>
We can make a few figures using <code>gnuplot</code>.
</p>

<div class="org-src-container">
<pre class="src src-gnuplot" id="orgc847b6c">unset key
set grid
set xlabel "Time (s)"
set ylabel "ADU at 360 nm"
plot 'toto' index 0 using 1:4 with points linecolor rgb "black" linewidth 2
</pre>
</div>



<div class="figure">
<p><img src="figs/data_test_plot_loading_curve.png" alt="data_test_plot_loading_curve.png" />
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgdc3b6d8" class="outline-4">
<h4 id="orgdc3b6d8"><span class="section-number-4">2.2.2</span> <code>adu_vector</code> header and source</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
Again, we define two code blocks for later use with the library. First the "header" part <code>&lt;&lt;adu_vector.h&gt;&gt;</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgaeb25ed">&lt;&lt;adu_vector-type-definition&gt;&gt;
adu_vector * adu_vector_alloc(size_t nelt);
int adu_vector_free(adu_vector * adu_vector_ptr);
int adu_vector_printf(adu_vector * padu_vector);
size_t data_get_nelt(hid_t file_id);
adu_vector * adu_vector_read_from_file(hid_t file_id);
</pre>
</div>

<p>
Next, the function definitions <code>&lt;&lt;adu_vector.c&gt;&gt;</code> stored in file <code>code/adu_vector.c</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org21951ba">/** \file adu_vector.c
    \brief Function definitions for [adu_vector](@ref adu_vector) structures
 */
#include "abaa.h"
&lt;&lt;adu_vector_alloc&gt;&gt;
&lt;&lt;adu_vector_free&gt;&gt;
&lt;&lt;data_get_nelt&gt;&gt;
&lt;&lt;adu_vector_read_from_file&gt;&gt;
&lt;&lt;adu_vector_printf&gt;&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd870dce" class="outline-3">
<h3 id="orgd870dce"><span class="section-number-3">2.3</span> <code>DYE</code></h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-org68bedde" class="outline-4">
<h4 id="org68bedde"><span class="section-number-4">2.3.1</span> DYE parameters in the <code>HDF5</code> files</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
The <code>DYE</code> group contains the following <i>scalar</i> datasets resulting from independent calibration experiments:
</p>

<dl class="org-dl">
<dt><code>R_min_hat</code></dt><dd>the estimated <code>R_min</code> parameter.</dd>
<dt><code>R_min_se</code></dt><dd>the estimated <code>R_min</code> standard error.</dd>
<dt><code>R_max_hat</code></dt><dd>the estimated <code>R_max</code> parameter.</dd>
<dt><code>R_max_se</code></dt><dd>the estimated <code>R_max</code> standard error.</dd>
<dt><code>K_eff_hat</code></dt><dd>the estimated <code>K_eff</code> parameter in \(\mu{}M\).</dd>
<dt><code>K_eff_se</code></dt><dd>the estimated <code>K_eff</code> standard error in \(\mu{}M\).</dd>
<dt><code>K_d_hat</code></dt><dd>the estimated <code>K_d</code> parameter in \(\mu{}M\).</dd>
<dt><code>K_d_se</code></dt><dd>the estimated <code>K_d</code> standard error in \(\mu{}M\).</dd>
<dt><code>pipette_concentration</code></dt><dd>the dye concentration in the pipette in \(\mu{}M\).</dd>
</dl>
</div>
</div>

<div id="outline-container-org3932969" class="outline-4">
<h4 id="org3932969"><span class="section-number-4">2.3.2</span> DYE parameters layout in <code>C</code> code</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
We create a structure with that looks exactly like the corresponding <code>HDF5</code> group.
</p>
</div>

<div id="outline-container-org00c38cc" class="outline-5">
<h5 id="org00c38cc"><span class="section-number-5">2.3.2.1</span> <code>dye</code> type definition</h5>
<div class="outline-text-5" id="text-2-3-2-1">
<div class="org-src-container">
<pre class="src src-C" id="org0a33ec1">/** @brief Structure holding dye parameters.
*/
typedef struct
{
  double R_min_hat; //!&lt; estimated `R_min` parameter
  double R_min_se; //!&lt; estimated `R_min` standard error
  double R_max_hat; //!&lt; estimated `R_max` parameter
  double R_max_se; //!&lt; estimated `R_max` standard error
  double K_eff_hat; //!&lt; estimated `K_eff` parameter in \f$\mu{}M\f$
  double K_eff_se; //!&lt; estimated `K_eff` standard error in \f$\mu{}M\f$
  double K_d_hat; //!&lt; estimated `K_d` parameter in \f$\mu{}M\f$
  double K_d_se; //!&lt; estimated `K_d` standard error in \f$\mu{}M\f$
  double pipette_concentration;//!&lt; dye concentration in the pipette in \f$\mu{}M\f$ 
} dye;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcdcdbe3" class="outline-5">
<h5 id="orgcdcdbe3"><span class="section-number-5">2.3.2.2</span> <code>&lt;&lt;dye_read_from_file&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-2-3-2-2">
<div class="org-src-container">
<pre class="src src-C" id="org51e4a2c">/** @brief Returns a `dye` structure
 *         read from Group DYE in a file
 *
 *  @param[in] file_id HDF5 file identifier
 *  @return a `dye` structure
 */
dye dye_read_from_file(hid_t file_id) {
  dye res;
  H5LTread_dataset_double(file_id,"/DYE/R_min_hat",&amp;res.R_min_hat);
  H5LTread_dataset_double(file_id,"/DYE/R_min_se",&amp;res.R_min_se);
  H5LTread_dataset_double(file_id,"/DYE/R_max_hat",&amp;res.R_max_hat);
  H5LTread_dataset_double(file_id,"/DYE/R_max_se",&amp;res.R_max_se);
  H5LTread_dataset_double(file_id,"/DYE/K_eff_hat",&amp;res.K_eff_hat);
  H5LTread_dataset_double(file_id,"/DYE/K_eff_se",&amp;res.K_eff_se);
  H5LTread_dataset_double(file_id,"/DYE/K_d_hat",&amp;res.K_d_hat);
  H5LTread_dataset_double(file_id,"/DYE/K_d_se",&amp;res.K_d_se);
  H5LTread_dataset_double(file_id,"/DYE/pipette_concentration",&amp;res.pipette_concentration);
  return res;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org1236170" class="outline-5">
<h5 id="org1236170"><span class="section-number-5">2.3.2.3</span> <code>&lt;&lt;dye_printf&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-2-3-2-3">
<div class="org-src-container">
<pre class="src src-C" id="org8d2bf5d">/** @brief Prints dye structure content to stdout
 *
 *  @param[in] pdye a pointer to a `dye` structure
 *  @return 0 if everything goes fine
 */
int dye_printf(dye * pdye) {
  printf("# DYE parameters\n");
  printf("# R_min_hat: %g\n",pdye-&gt;R_min_hat);
  printf("# R_min_se: %g\n",pdye-&gt;R_min_se);
  printf("# R_max_hat: %g\n",pdye-&gt;R_max_hat);
  printf("# R_max_se: %g\n",pdye-&gt;R_max_se);
  printf("# K_eff_hat: %g\n",pdye-&gt;K_eff_hat);
  printf("# K_eff_se: %g\n",pdye-&gt;K_eff_se);
  printf("# K_d_hat: %g\n",pdye-&gt;K_d_hat);
  printf("# K_d_se: %g\n",pdye-&gt;K_d_se);
  printf("# pipette_concentration: %g\n\n",pdye-&gt;pipette_concentration);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9f52ab9" class="outline-5">
<h5 id="org9f52ab9"><span class="section-number-5">2.3.2.4</span> <code>dye_test</code></h5>
<div class="outline-text-5" id="text-2-3-2-4">
<p>
We now write a short program, <code>dye_test.c</code>, testing our new functions:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgea6c36a">/** @file dye_test.c
 *  @brief test functions reading DYE data from an HDF5 file
 *         and printing them to the stdout 
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;hdf5.h&gt;
#include &lt;hdf5_hl.h&gt;
#include &lt;gsl/gsl_vector.h&gt;
&lt;&lt;dye-type-definition&gt;&gt;
&lt;&lt;dye_read_from_file&gt;&gt;
&lt;&lt;dye_printf&gt;&gt;
#define FNAME "data_paper/data_beta_escin/DA_121219_E1.h5"
int main()
{
  // Open FILE
  char fname[] = FNAME;
  hid_t fid = H5Fopen (fname, H5F_ACC_RDONLY, H5P_DEFAULT);
  dye dye_st = dye_read_from_file(fid);
  // Close file
  H5Fclose (fid);
  dye_printf(&amp;dye_st);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgac31bd5" class="outline-5">
<h5 id="orgac31bd5"><span class="section-number-5">2.3.2.5</span> <code>dye_test</code> compilation, run, etc</h5>
<div class="outline-text-5" id="text-2-3-2-5">
<p>
We compile the code with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgf9acacb">gcc -Wall -g -o code/dye_test code/dye_test.c -lhdf5 -lhdf5_hl -lm -std=gnu11
</pre>
</div>

<p>
We now run it with valgrind:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgb259345">valgrind ./code/dye_test 
</pre>
</div>

<pre class="example">
==14957== Memcheck, a memory error detector
==14957== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==14957== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info
==14957== Command: ./code/dye_test
==14957== 
# DYE parameters
# R_min_hat: 0.147143
# R_min_se: 0.00623826
# R_max_hat: 1.59923
# R_max_se: 0.0711322
# K_eff_hat: 1.09304
# K_eff_se: 0.362558
# K_d_hat: 0.225167
# K_d_se: 0.0114915
# pipette_concentration: 200

==14957== 
==14957== HEAP SUMMARY:
==14957==     in use at exit: 0 bytes in 0 blocks
==14957==   total heap usage: 3,497 allocs, 3,497 frees, 1,233,749 bytes allocated
==14957== 
==14957== All heap blocks were freed -- no leaks are possible
==14957== 
==14957== For counts of detected and suppressed errors, rerun with: -v
==14957== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfb6a259" class="outline-4">
<h4 id="orgfb6a259"><span class="section-number-4">2.3.3</span> <code>dye</code> header and source</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
For later use, the "header part", <code>&lt;&lt;dye.h&gt;&gt;</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org8023c37">&lt;&lt;dye-type-definition&gt;&gt;
dye dye_read_from_file(hid_t file_id);
int dye_printf(dye * pdye);
</pre>
</div>

<p>
The function definitions <code>&lt;&lt;dye.c&gt;&gt;</code> stored in file <code>code/dye.c</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org1fed2b4">/** \file dye.c
    \brief Function definitions for [dye](@ref dye) structures
 */
#include "abaa.h"
&lt;&lt;dye_read_from_file&gt;&gt;
&lt;&lt;dye_printf&gt;&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org59cf272" class="outline-3">
<h3 id="org59cf272"><span class="section-number-3">2.4</span> <code>ILLUMINATION</code></h3>
<div class="outline-text-3" id="text-2-4">
</div>
<div id="outline-container-org5f95a39" class="outline-4">
<h4 id="org5f95a39"><span class="section-number-4">2.4.1</span> <code>ILLUMINATION</code> parameters in the <code>HDF5</code> files</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
The <code>ILLUMINATION</code> group contains the following <i>scalar</i> datasets:
</p>

<dl class="org-dl">
<dt><code>T_340</code></dt><dd>illumination duration at 340 nm in seconds.</dd>
<dt><code>T_360</code></dt><dd>illumination duration at 360 nm in seconds.</dd>
<dt><code>T_380</code></dt><dd>illumination duration at 380 nm in seconds.</dd>
</dl>
</div>
</div>

<div id="outline-container-orgfa477b6" class="outline-4">
<h4 id="orgfa477b6"><span class="section-number-4">2.4.2</span> <code>ILLUMINATION</code> parameters layout in <code>C</code> code</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
We create a structure with that looks exactly like the corresponding <code>HDF5</code> group.
</p>
</div>


<div id="outline-container-orgf304249" class="outline-5">
<h5 id="orgf304249"><span class="section-number-5">2.4.2.1</span> <code>illumination</code> type definition</h5>
<div class="outline-text-5" id="text-2-4-2-1">
<div class="org-src-container">
<pre class="src src-C" id="org1f9e202">/** @brief Structure holding illumination parameters.
*/
typedef struct
{
  double T_340; //!&lt; illumination duration at 340 nm (s)
  double T_360; //!&lt; illumination duration at 360 nm (s)
  double T_380; //!&lt; illumination duration at 380 nm (s)
} illumination;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd8a55f5" class="outline-5">
<h5 id="orgd8a55f5"><span class="section-number-5">2.4.2.2</span> <code>&lt;&lt;illumination_read_from_file&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-2-4-2-2">
<div class="org-src-container">
<pre class="src src-C" id="orgf56567a">/** @brief Returns a `illumination` structure
 *         read from Group ILLUMINATION in a file
 *
 *  @param[in] file_id HDF5 file identifier
 *  @return a `illumination` structure
 */
illumination illumination_read_from_file(hid_t file_id) {
  illumination res;
  H5LTread_dataset_double(file_id,"/ILLUMINATION/T_340",&amp;res.T_340);
  H5LTread_dataset_double(file_id,"/ILLUMINATION/T_360",&amp;res.T_360);
  H5LTread_dataset_double(file_id,"/ILLUMINATION/T_380",&amp;res.T_380);
  return res;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge1b125f" class="outline-5">
<h5 id="orge1b125f"><span class="section-number-5">2.4.2.3</span> <code>&lt;&lt;illumination_printf&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-2-4-2-3">
<div class="org-src-container">
<pre class="src src-C" id="orgd8e64a8">/** @brief Prints illumination structure content to stdout
 *
 *  @param[in] pillumination a pointer to a `illumination` structure
 *  @return 0 if everything goes fine
 */
int illumination_printf(illumination * pillumination) {
  printf("# ILLUMINATION parameters\n");
  printf("# T_340: %g\n",pillumination-&gt;T_340);
  printf("# T_360: %g\n",pillumination-&gt;T_360);
  printf("# T_380: %g\n\n",pillumination-&gt;T_380);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org55d25e5" class="outline-5">
<h5 id="org55d25e5"><span class="section-number-5">2.4.2.4</span> <code>illumination_test</code></h5>
<div class="outline-text-5" id="text-2-4-2-4">
<p>
We now write a short program, <code>illumination_test.c</code>, testing our new functions:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgccaf6bd">/** @file illumination_test.c
 *  @brief test functions reading ILLUMINATION data from an HDF5 file
 *         and printing them to the stdout 
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;hdf5.h&gt;
#include &lt;hdf5_hl.h&gt;
#include &lt;gsl/gsl_vector.h&gt;
&lt;&lt;illumination-type-definition&gt;&gt;
&lt;&lt;illumination_read_from_file&gt;&gt;
&lt;&lt;illumination_printf&gt;&gt;
#define FNAME "data_paper/data_beta_escin/DA_121219_E1.h5"
int main()
{
  // Open FILE
  char fname[] = FNAME;
  hid_t fid = H5Fopen (fname, H5F_ACC_RDONLY, H5P_DEFAULT);
  illumination illumination_st = illumination_read_from_file(fid);
  // Close file
  H5Fclose (fid);
  illumination_printf(&amp;illumination_st);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org7d64476" class="outline-5">
<h5 id="org7d64476"><span class="section-number-5">2.4.2.5</span> <code>illumination_test</code> compilation, run, etc</h5>
<div class="outline-text-5" id="text-2-4-2-5">
<p>
We compile the code with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org0cb1200">gcc -Wall -g -o code/illumination_test code/illumination_test.c -lhdf5 -lhdf5_hl -lm -std=gnu11
</pre>
</div>

<p>
We now run it with valgrind:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org76bd9da">valgrind ./code/illumination_test 
</pre>
</div>

<pre class="example">
==14967== Memcheck, a memory error detector
==14967== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==14967== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info
==14967== Command: ./code/illumination_test
==14967== 
# ILLUMINATION parameters
# T_340: 0.01
# T_360: 0.003
# T_380: 0.003

==14967== 
==14967== HEAP SUMMARY:
==14967==     in use at exit: 0 bytes in 0 blocks
==14967==   total heap usage: 3,199 allocs, 3,199 frees, 964,286 bytes allocated
==14967== 
==14967== All heap blocks were freed -- no leaks are possible
==14967== 
==14967== For counts of detected and suppressed errors, rerun with: -v
==14967== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>
</div>
</div>
</div>

<div id="outline-container-org57feea6" class="outline-4">
<h4 id="org57feea6"><span class="section-number-4">2.4.3</span> <code>illumination</code> header and source</h4>
<div class="outline-text-4" id="text-2-4-3">
<p>
The header part in code block <code>&lt;&lt;illumination.h&gt;&gt;</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org69bd2e9">&lt;&lt;illumination-type-definition&gt;&gt;
illumination illumination_read_from_file(hid_t file_id);
int illumination_printf(illumination * pillumination);
</pre>
</div>

<p>
The function definitions <code>&lt;&lt;illumination.c&gt;&gt;</code> stored in file <code>code/illumination.c</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org8ee17eb">/** \file illumination.c
    \brief Function definitions for [illumination](@ref illumination) structures.
 */
#include "abaa.h"
&lt;&lt;illumination_read_from_file&gt;&gt;
&lt;&lt;illumination_printf&gt;&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga77590f" class="outline-3">
<h3 id="orga77590f"><span class="section-number-3">2.5</span> <code>CCD</code></h3>
<div class="outline-text-3" id="text-2-5">
</div>
<div id="outline-container-orgdbaeb36" class="outline-4">
<h4 id="orgdbaeb36"><span class="section-number-4">2.5.1</span> <code>CCD</code> parameters in the <code>HDF5</code> files</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
The <code>CCD</code> group contains the following <i>scalar</i> datasets:
</p>

<dl class="org-dl">
<dt><code>GAIN</code></dt><dd>the CCD chip gain (from calibration experiments).</dd>
<dt><code>S_RO</code></dt><dd>the read-out standard deviation of the CCD chip (from calibration experiments).</dd>
<dt><code>P</code></dt><dd>the number of pixels in the <code>Region Of Interest</code> (ROI); <i>the read-out variance should be added as many times as there are pixels when one computes the measurements variance</i>.</dd>
<dt><code>P_B</code></dt><dd>the number of pixels in the "background" <code>Region Of Interest</code> (ROB).</dd>
</dl>
</div>
</div>

<div id="outline-container-org5042912" class="outline-4">
<h4 id="org5042912"><span class="section-number-4">2.5.2</span> <code>CCD</code> parameters layout in <code>C</code> code</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
We create a structure with that looks exactly like the corresponding <code>HDF5</code> group.
</p>
</div>

<div id="outline-container-org1aec57c" class="outline-5">
<h5 id="org1aec57c"><span class="section-number-5">2.5.2.1</span> <code>ccd</code> type definition</h5>
<div class="outline-text-5" id="text-2-5-2-1">
<p>
We store the <i>read-out variance</i> and not the read-out standard deviation.
</p>

<div class="org-src-container">
<pre class="src src-C" id="orga546bde">/** @brief Structure holding ccd parameters.
*/
typedef struct
{
  double gain; //!&lt; CCD chip gain
  double s2; //!&lt; CCD chip read-out variance
  size_t P; //!&lt; number of pixels in ROI
  size_t P_B; //!&lt; number of pixels in ROB
} ccd;
</pre>
</div>
</div>
</div>

<div id="outline-container-org922808b" class="outline-5">
<h5 id="org922808b"><span class="section-number-5">2.5.2.2</span> <code>&lt;&lt;ccd_read_from_file&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-2-5-2-2">
<div class="org-src-container">
<pre class="src src-C" id="orgc31f832">/** @brief Returns a `ccd` structure
 *         read from Group CCD in a file
 *
 *  @param[in] file_id HDF5 file identifier
 *  @return a `ccd` structure
 */
ccd ccd_read_from_file(hid_t file_id) {
  ccd res;
  H5LTread_dataset_double(file_id,"/CCD/GAIN",&amp;res.gain);
  double value;
  H5LTread_dataset_double(file_id,"/CCD/S_RO",&amp;value);
  res.s2 = value*value;
  int n;
  H5LTread_dataset_int(file_id,"/CCD/P",&amp;n);
  res.P = (size_t) n;
  H5LTread_dataset_int(file_id,"/CCD/P_B",&amp;n);
  res.P_B = (size_t) n;
  return res;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org1908d46" class="outline-5">
<h5 id="org1908d46"><span class="section-number-5">2.5.2.3</span> <code>&lt;&lt;ccd_printf&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-2-5-2-3">
<div class="org-src-container">
<pre class="src src-C" id="org3f32c06">/** @brief Prints `ccd` structure content to stdout
 *
 *  @param[in] pccd a pointer to a `ccd` structure
 *  @return 0 if everything goes fine
 */
int ccd_printf(ccd * pccd) {
  printf("# CCD parameters\n");
  printf("# Gain: %g\n",pccd-&gt;gain);
  printf("# Read-out variance: %g\n",pccd-&gt;s2);
  printf("# P: %d\n", (int) pccd-&gt;P);
  printf("# P_B: %d\n\n", (int) pccd-&gt;P_B);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org10a6414" class="outline-5">
<h5 id="org10a6414"><span class="section-number-5">2.5.2.4</span> <code>ccd_test</code></h5>
<div class="outline-text-5" id="text-2-5-2-4">
<p>
We now write a short program, <code>ccd_test.c</code>, testing our new functions:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orged47eb2">/** @file ccd_test.c
 *  @brief test functions reading CCD data from an HDF5 file
 *         and printing them to the stdout 
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;hdf5.h&gt;
#include &lt;hdf5_hl.h&gt;
#include &lt;gsl/gsl_vector.h&gt;
&lt;&lt;ccd-type-definition&gt;&gt;
&lt;&lt;ccd_read_from_file&gt;&gt;
&lt;&lt;ccd_printf&gt;&gt;
#define FNAME "data_paper/data_beta_escin/DA_121219_E1.h5"
int main()
{
  // Open FILE
  char fname[] = FNAME;
  hid_t fid = H5Fopen (fname, H5F_ACC_RDONLY, H5P_DEFAULT);
  ccd ccd_st = ccd_read_from_file(fid);
  // Close file
  H5Fclose (fid);
  ccd_printf(&amp;ccd_st);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf474f23" class="outline-5">
<h5 id="orgf474f23"><span class="section-number-5">2.5.2.5</span> <code>ccd_test</code> compilation, run, etc</h5>
<div class="outline-text-5" id="text-2-5-2-5">
<p>
We compile the code with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org39a7027">gcc -Wall -g -o code/ccd_test code/ccd_test.c -lhdf5 -lhdf5_hl -lm -std=gnu11
</pre>
</div>

<p>
We now run it with valgrind:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org80eec9c">valgrind ./code/ccd_test 
</pre>
</div>

<pre class="example">
==14975== Memcheck, a memory error detector
==14975== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==14975== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info
==14975== Command: ./code/ccd_test
==14975== 
# CCD parameters
# Gain: 0.146
# Read-out variance: 268.96
# P: 3
# P_B: 448

==14975== 
==14975== HEAP SUMMARY:
==14975==     in use at exit: 0 bytes in 0 blocks
==14975==   total heap usage: 3,251 allocs, 3,251 frees, 1,008,863 bytes allocated
==14975== 
==14975== All heap blocks were freed -- no leaks are possible
==14975== 
==14975== For counts of detected and suppressed errors, rerun with: -v
==14975== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdfe14dd" class="outline-4">
<h4 id="orgdfe14dd"><span class="section-number-4">2.5.3</span> <code>ccd</code> header and source</h4>
<div class="outline-text-4" id="text-2-5-3">
<p>
The header part in code block <code>&lt;&lt;ccd.h&gt;&gt;</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orge7f04fb">&lt;&lt;ccd-type-definition&gt;&gt;
ccd ccd_read_from_file(hid_t file_id);
int ccd_printf(ccd * pccd);
</pre>
</div>

<p>
The function definitions <code>&lt;&lt;ccd.c&gt;&gt;</code> stored in file <code>code/ccd.c</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orge62033b">/** \file ccd.c
    \brif Function definitions for [ccd](@ref ccd) structures.
 */
#include "abaa.h"
&lt;&lt;ccd_read_from_file&gt;&gt;
&lt;&lt;ccd_printf&gt;&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgbdee825" class="outline-3">
<h3 id="orgbdee825"><span class="section-number-3">2.6</span> Keeping everything in one structure</h3>
<div class="outline-text-3" id="text-2-6">
<p>
We now define a new structure that holds everything.
</p>
</div>

<div id="outline-container-orgf6a27c5" class="outline-4">
<h4 id="orgf6a27c5"><span class="section-number-4">2.6.1</span> <code>aba</code> an added buffer approach structure:</h4>
<div class="outline-text-4" id="text-2-6-1">
</div>
<div id="outline-container-org3756893" class="outline-5">
<h5 id="org3756893"><span class="section-number-5">2.6.1.1</span> <code>aba</code> type definition</h5>
<div class="outline-text-5" id="text-2-6-1-1">
<div class="org-src-container">
<pre class="src src-C" id="org4a38998">/** \brief Structure holding all the data
 */
typedef struct 
{
  adu_vector * data; //!&lt; a pointer to an adu_vector
  dye dye; //!&lt; dye parameters
  illumination light; //!&lt; illumination parameters
  ccd ccd; //!&lt; ccd chip parameters
} aba;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgabb49c1" class="outline-5">
<h5 id="orgabb49c1"><span class="section-number-5">2.6.1.2</span> <code>aba_alloc</code></h5>
<div class="outline-text-5" id="text-2-6-1-2">
<div class="org-src-container">
<pre class="src src-C" id="org4f63d54">/** \brief Allocates an [aba](@ref aba) structure
 
    The function allocates memory for an [aba](@ref aba) structure
  
    @returns a pointer to an allocated [aba](@ref aba)
*/
aba * aba_alloc()
{
  aba * res = malloc(sizeof(aba));
  return res;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org16d7b6f" class="outline-5">
<h5 id="org16d7b6f"><span class="section-number-5">2.6.1.3</span> <code>aba_free</code></h5>
<div class="outline-text-5" id="text-2-6-1-3">
<div class="org-src-container">
<pre class="src src-C" id="orgbefc637">/** @brief Frees an [aba](@ref aba)
 
    @param[in,out] aba_ptr a pointer to an allocated [aba](@ref aba) structure
    @returns 0 if everything goes fine 
*/
int aba_free(aba * paba)
{
  adu_vector_free(paba-&gt;data);
  free(paba);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga50cf78" class="outline-5">
<h5 id="orga50cf78"><span class="section-number-5">2.6.1.4</span> <code>aba_read_from_file</code></h5>
<div class="outline-text-5" id="text-2-6-1-4">
<div class="org-src-container">
<pre class="src src-C" id="org545444d">/** \brief Reads the content of an opened HDF5 file
           and stores the result in an [aba](@ref aba)

    \param[in] file_id pointer to an opened HDF5 file
    \return a pointer to an allocated and intialized [aba](@ref aba)
 */
aba * aba_read_from_file(hid_t file_id)
{
  aba * res = aba_alloc();
  res-&gt;data = adu_vector_read_from_file(file_id);
  res-&gt;dye = dye_read_from_file(file_id);
  res-&gt;light = illumination_read_from_file(file_id);
  res-&gt;ccd = ccd_read_from_file(file_id);
  return res;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8d433b6" class="outline-5">
<h5 id="org8d433b6"><span class="section-number-5">2.6.1.5</span> <code>aba_printf</code></h5>
<div class="outline-text-5" id="text-2-6-1-5">
<div class="org-src-container">
<pre class="src src-C" id="org9b4eebe">/** @brief Prints [aba](@ref aba) content to stdout
 
    @param[in] paba a pointer to an [aba](@ref aba) structure
    @return 0 if everything goes fine
 */
int aba_printf(aba * paba)
{
  dye_printf(&amp;(paba-&gt;dye));
  ccd_printf(&amp;(paba-&gt;ccd));
  illumination_printf(&amp;(paba-&gt;light));
  adu_vector_printf(paba-&gt;data);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org24068e0" class="outline-5">
<h5 id="org24068e0"><span class="section-number-5">2.6.1.6</span> <code>aba_test</code> program definition</h5>
<div class="outline-text-5" id="text-2-6-1-6">
<p>
We now write a short program, <code>aba_test.c</code>, testing our new functions:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org9aec32f">/** @file aba_test.c
 *  @brief test functions reading data from an HDF5 file
 *         and printing them to the stdout 
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;hdf5.h&gt;
#include &lt;hdf5_hl.h&gt;
#include &lt;gsl/gsl_vector.h&gt;
&lt;&lt;adu-type-definition&gt;&gt;
&lt;&lt;adu_alloc&gt;&gt;
&lt;&lt;adu_free&gt;&gt;
&lt;&lt;adu_get_set&gt;&gt;
&lt;&lt;adu_vector-type-definition&gt;&gt;
&lt;&lt;adu_vector_alloc&gt;&gt;
&lt;&lt;adu_vector_free&gt;&gt;
&lt;&lt;data_get_nelt&gt;&gt;
&lt;&lt;adu_vector_read_from_file&gt;&gt;
&lt;&lt;adu_printf&gt;&gt;
&lt;&lt;adu_vector_printf&gt;&gt;
&lt;&lt;dye-type-definition&gt;&gt;
&lt;&lt;dye_read_from_file&gt;&gt;
&lt;&lt;dye_printf&gt;&gt;
&lt;&lt;illumination-type-definition&gt;&gt;
&lt;&lt;illumination_read_from_file&gt;&gt;
&lt;&lt;illumination_printf&gt;&gt;
&lt;&lt;ccd-type-definition&gt;&gt;
&lt;&lt;ccd_read_from_file&gt;&gt;
&lt;&lt;ccd_printf&gt;&gt;
&lt;&lt;aba-type-definition&gt;&gt;
&lt;&lt;aba_alloc&gt;&gt;
&lt;&lt;aba_free&gt;&gt;
&lt;&lt;aba_read_from_file&gt;&gt;
&lt;&lt;aba_printf&gt;&gt;
#define FNAME "data_paper/data_beta_escin/DA_121219_E1.h5"
int main()
{
  // Open FILE
  char fname[] = FNAME;
  hid_t fid = H5Fopen (fname, H5F_ACC_RDONLY, H5P_DEFAULT);
  aba * paba = aba_read_from_file(fid);
  // Close file
  H5Fclose (fid);
  aba_printf(paba);
  aba_free(paba);
  return 0;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org5ac9740" class="outline-5">
<h5 id="org5ac9740"><span class="section-number-5">2.6.1.7</span> <code>aba_test</code> compilation and run</h5>
<div class="outline-text-5" id="text-2-6-1-7">
<p>
We compile the code with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgd468c99">gcc -Wall -g -o code/aba_test code/aba_test.c -lgsl -lgslcblas -lhdf5 -lhdf5_hl -lm -std=gnu11
</pre>
</div>

<p>
We run it with valgrind:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgdac1fb5">valgrind ./code/aba_test &gt; toto
</pre>
</div>

<pre class="example">
==14983== Memcheck, a memory error detector
==14983== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==14983== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info
==14983== Command: ./code/aba_test
==14983== 
==14983== 
==14983== HEAP SUMMARY:
==14983==     in use at exit: 0 bytes in 0 blocks
==14983==   total heap usage: 4,834 allocs, 4,834 frees, 2,402,637 bytes allocated
==14983== 
==14983== All heap blocks were freed -- no leaks are possible
==14983== 
==14983== For counts of detected and suppressed errors, rerun with: -v
==14983== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>

<p>
We can check the first lines of the file with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org4eb5f25">./code/aba_test | head -n 30
</pre>
</div>

<pre class="example">
# DYE parameters
# R_min_hat: 0.147143
# R_min_se: 0.00623826
# R_max_hat: 1.59923
# R_max_se: 0.0711322
# K_eff_hat: 1.09304
# K_eff_se: 0.362558
# K_d_hat: 0.225167
# K_d_se: 0.0114915
# pipette_concentration: 200

# CCD parameters
# Gain: 0.146
# Read-out variance: 268.96
# P: 3
# P_B: 448

# ILLUMINATION parameters
# T_340: 0.01
# T_360: 0.003
# T_380: 0.003

# Loading curve with 104 elements
#    Time   ADU340  ADU340B   ADU360  ADU360B   ADU380  ADU380B
    0.021      979   142343      988   141856     1049   153272
   30.021      943   141974      980   141505     1058   153314
   60.021      980   141816      973   141148     1051   153637
   90.021      962   141874      977   141411     1038   153397
  120.021      978   142411      972   141660     1056   153538
  150.021      979   141842      980   141473     1073   153736
</pre>


<p>
And the last lines with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org8cb4e77">./code/aba_test | tail
</pre>
</div>

<pre class="example">
 3469.215     3129   112060     3541   110349     4113   126799
 3469.315     3143   112072     3559   110474     4113   126914
 3469.415     3113   111978     3576   110281     4173   127001
 3469.515     3125   112120     3525   110584     4151   126857
 3469.615     3099   112026     3578   110473     4196   126917
 3469.715     3130   111965     3575   110571     4132   126905
 3469.815     3116   112025     3586   110532     4183   126895
 3469.915     3104   112065     3519   110560     4171   127004


</pre>
</div>
</div>
</div>


<div id="outline-container-org7982c8e" class="outline-4">
<h4 id="org7982c8e"><span class="section-number-4">2.6.2</span> <code>aba</code> header and source</h4>
<div class="outline-text-4" id="text-2-6-2">
<p>
The header part in code block <code>&lt;&lt;aba.h&gt;&gt;</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgcd537d2">&lt;&lt;aba-type-definition&gt;&gt;
aba * aba_alloc();
int aba_free(aba * paba);
aba * aba_read_from_file(hid_t file_id);
int aba_printf(aba * paba);
</pre>
</div>

<p>
The function definitions <code>&lt;&lt;aba.c&gt;&gt;</code> stored in file <code>code/aba.c</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orga59df32">/** \file aba.c
    \brief Function definitions for [aba](@ref aba) structures. 
 */
#include "abaa.h"
&lt;&lt;aba_alloc&gt;&gt;
&lt;&lt;aba_free&gt;&gt;
&lt;&lt;aba_read_from_file&gt;&gt;
&lt;&lt;aba_printf&gt;&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1e0a634" class="outline-3">
<h3 id="org1e0a634"><span class="section-number-3">2.7</span> Getting [Fura] estimates</h3>
<div class="outline-text-3" id="text-2-7">
<p>
We define now a <code>time_series</code> structure and functions for getting [Fura] estimates from an <code>aba</code> structure.
</p>
</div>
<div id="outline-container-org3c9a42f" class="outline-4">
<h4 id="org3c9a42f"><span class="section-number-4">2.7.1</span> <code>time_series</code> structure</h4>
<div class="outline-text-4" id="text-2-7-1">
</div>
<div id="outline-container-org9a727ca" class="outline-5">
<h5 id="org9a727ca"><span class="section-number-5">2.7.1.1</span> <code>ts</code> type definition</h5>
<div class="outline-text-5" id="text-2-7-1-1">
<div class="org-src-container">
<pre class="src src-C" id="org8ff4de5">/** \struct ts
    \brief A two members structure (two pointeres to gsl_vectors
           holding time and amplitude from a time series.
 */
typedef struct
{
  gsl_vector * TIME; //!&lt; a pointer to a gsl_vector holding times
  gsl_vector * AMPLITUDE; //!&lt; a pointer to a gsl_vector holding amplitudes
} ts;
</pre>
</div>
</div>
</div>

<div id="outline-container-org1cdffbc" class="outline-5">
<h5 id="org1cdffbc"><span class="section-number-5">2.7.1.2</span> <code>ts_alloc</code></h5>
<div class="outline-text-5" id="text-2-7-1-2">
<div class="org-src-container">
<pre class="src src-C" id="org6142607">/** \brief Allocates a [ts](@ref ts)
 
    The function allocates memory for a [ts](@ref ts) structure
    
    \param[in] n_obs the number of obserations 
    \returns a pointer to an allocated [ts](@ref ts)
*/
ts * ts_alloc(size_t n_obs) {
  ts * res = malloc(sizeof(ts));
  res-&gt;TIME = gsl_vector_alloc(n_obs);
  res-&gt;AMPLITUDE = gsl_vector_alloc(n_obs);
  return res;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge8d6bcd" class="outline-5">
<h5 id="orge8d6bcd"><span class="section-number-5">2.7.1.3</span> <code>ts_free</code></h5>
<div class="outline-text-5" id="text-2-7-1-3">
<div class="org-src-container">
<pre class="src src-C" id="orgd016f5e">/** @fn int ts_free(ts * pts)
    @brief Frees memory taken up by a [ts](@ref ts)
    
    @param[in,out] ptd a pointer to a [ts](@ref ts)
    @returns 0 if everything goes fine
*/
int ts_free(ts * pts) {
  gsl_vector_free(pts-&gt;TIME);
  gsl_vector_free(pts-&gt;AMPLITUDE);
  free(pts);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf10564b" class="outline-5">
<h5 id="orgf10564b"><span class="section-number-5">2.7.1.4</span> <code>ts_fprintf</code> definition</h5>
<div class="outline-text-5" id="text-2-7-1-4">
<p>
We now define a function that prints to <code>STREAM</code> the content of an <code>ts</code> structure:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orge732893">/** @brief Prints  [ts](@ref ts) content to `stream`
 
    @param[in] stream a pointer to an output "file"
    @param[in] pts a pointer to a [ts](@ref ts) structure
    @return 0 if everything goes fine
 */
int ts_fprintf(FILE * stream, ts * pts) {
  size_t nobs=(pts)-&gt;TIME-&gt;size;
  fprintf(stream,"#    Time   AMPLITUDE\n");
  for (size_t i=0; i&lt;nobs; i++) {
    fprintf(stream,
	    "%9.9g %9.9g\n",
	    adu_get((pts),TIME,i),
	    adu_get((pts),AMPLITUDE,i));
  }
  fprintf(stream,"\n\n");
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdc020b0" class="outline-5">
<h5 id="orgdc020b0"><span class="section-number-5">2.7.1.5</span> <code>ts_vector</code></h5>
<div class="outline-text-5" id="text-2-7-1-5">
<div class="org-src-container">
<pre class="src src-C" id="orgff64529">/** \struct ts_vector
    \brief Structure holding arrays of [ts](@ref ts) structures .
*/
typedef struct
{
  size_t nelt; //!&lt; number of elements in the vector
  ts ** ts_v; //!&lt; array of pointers to [ts](@ref ts) structures
} ts_vector;
</pre>
</div>
</div>
</div>

<div id="outline-container-org5ad2c53" class="outline-5">
<h5 id="org5ad2c53"><span class="section-number-5">2.7.1.6</span> <code>ts_vector_alloc</code>  definition</h5>
<div class="outline-text-5" id="text-2-7-1-6">
<p>
It will be helpful to have an <code>alloc</code> function for <code>ts_vector</code> structures:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org0fe2250">/** @brief Allocates an [ts_vector](@ref ts_vector)
 *
 *  The function allocates memory for a [ts_vector](@ref ts_vector) structure
 *
 *  @param[in] nelt the number of stimulation 
 *  @returns a pointer to an allocated [ts_vector](@ref ts_vector)
*/
ts_vector * ts_vector_alloc(size_t nelt) {
  ts_vector * res = malloc(sizeof(ts_vector));
  res-&gt;nelt = nelt;
  res-&gt;ts_v = malloc(nelt*sizeof(ts));
  return res;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org15d452b" class="outline-5">
<h5 id="org15d452b"><span class="section-number-5">2.7.1.7</span> <code>ts_vector_free</code> definition</h5>
<div class="outline-text-5" id="text-2-7-1-7">
<p>
It will also be helpful to have a <code>free</code> function for <code>ts_vector</code> structures:
</p>
<div class="org-src-container">
<pre class="src src-C" id="orgd56a778">/** @brief Frees a [ts_vector](@ref ts_vector)
 *
 *  @param[in,out] pts_vector a pointer to an allocated [ts_vector](@ref ts_vector) structure
 *  @returns 0 if everything goes fine 
*/
int ts_vector_free(ts_vector * pts_vector) {
  for (size_t d_idx=0; d_idx&lt;pts_vector-&gt;nelt; d_idx++) 
    ts_free(pts_vector-&gt;ts_v[d_idx]);
  free(pts_vector-&gt;ts_v);
  free(pts_vector);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org75b700f" class="outline-5">
<h5 id="org75b700f"><span class="section-number-5">2.7.1.8</span> <code>ts_vector_fprintf</code> definition</h5>
<div class="outline-text-5" id="text-2-7-1-8">
<p>
We now define a function that prints to a <code>stream</code> the content of a <code>ts_vector</code> structure:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org0cf8d08">/** @brief Prints [ts_vector](@ref ts_vector) content to `stream`
 
    @param[in] stream a pointer to an output "file"
    @param[in] pts_vector a pointer to a [ts_vector](@ref ts_vector) structure
    @return 0 if everything goes fine
 */
int ts_vector_fprintf(FILE * stream, ts_vector * pts_vector) {
  for (size_t d_idx=0; d_idx&lt;pts_vector-&gt;nelt; d_idx++) {
    size_t nobs=(pts_vector-&gt;ts_v[d_idx])-&gt;TIME-&gt;size;
    if (d_idx == 0) {
      fprintf(stream,"# Loading curve with %d elements\n", (int) nobs);
    } else {
      fprintf(stream,"# Stim %d with %d elements\n", (int) d_idx, (int) nobs);
    }
    ts_fprintf(stream,pts_vector-&gt;ts_v[d_idx]);
  }
  return 0;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org58cd94d" class="outline-4">
<h4 id="org58cd94d"><span class="section-number-4">2.7.2</span> Getting a [Fura] estimation</h4>
<div class="outline-text-4" id="text-2-7-2">
</div>
<div id="outline-container-orgee1fbc0" class="outline-5">
<h5 id="orgee1fbc0"><span class="section-number-5">2.7.2.1</span> <code>fura_est</code></h5>
<div class="outline-text-5" id="text-2-7-2-1">
<p>
We define a function taking a pointer to an <code>aba</code> structure and returning the estimated [Fura] from it as a [ts_vector] structure.
</p>

<div class="org-src-container">
<pre class="src src-C" id="org89bdf54">/** \fn ts_vector * fura_est(aba * paba)
    \brief Get [Fura] time series from [aba](@ref aba) structure

    __It is assumed that when the maximal background subtracted fluorescence at
    360 nm is observed, the fura concentration in the cell and in the pipette
    are identical (no extrapolation based on a fit is performed).__

    \param[in] paba a pointer to an [aba](@ref aba) structure
    \return a pointer to an allocated and initialized [ts_vector](@ref ts_vector)
 */
ts_vector * fura_est(aba * paba) {
  // Get the number of stim + 1 in paba
  size_t nelt=paba-&gt;data-&gt;nelt;
  // Allocates result
  ts_vector *res=ts_vector_alloc(nelt);
  // Get [Fura] in the pipette
  double F_p = paba-&gt;dye.pipette_concentration;
  // Get the inverse of the number of pixels in ROI
  double inv_P = 1.0/(double)paba-&gt;ccd.P;
  // Get the inverse of the number of pixels in ROB
  double inv_P_B = 1.0/(double)paba-&gt;ccd.P_B;
  double max_adu;
  for (size_t i=0; i&lt;nelt; i++) {
    gsl_vector *adu360 = paba-&gt;data-&gt;adu_v[i]-&gt;ADU360;
    gsl_vector *adu360B = paba-&gt;data-&gt;adu_v[i]-&gt;ADU360B;
    gsl_vector *time = paba-&gt;data-&gt;adu_v[i]-&gt;TIME;
    res-&gt;ts_v[i] = ts_alloc(adu360-&gt;size);
    for (size_t j=0; j&lt;adu360-&gt;size; j++) {
      double fura_c = gsl_vector_get(adu360,j)*inv_P-
	gsl_vector_get(adu360B,j)*inv_P_B;
      gsl_vector_set(res-&gt;ts_v[i]-&gt;AMPLITUDE,j,fura_c);
      gsl_vector_set(res-&gt;ts_v[i]-&gt;TIME,j,gsl_vector_get(time,j));
    }
    if (i == 0)
      max_adu = gsl_vector_max(res-&gt;ts_v[i]-&gt;AMPLITUDE);
    gsl_vector_scale(res-&gt;ts_v[i]-&gt;AMPLITUDE,F_p/max_adu);
  }
  return res;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org57e10d3" class="outline-4">
<h4 id="org57e10d3"><span class="section-number-4">2.7.3</span> <code>fura</code> header and source</h4>
<div class="outline-text-4" id="text-2-7-3">
<p>
Again, we define two code blocks for later use with the library. First the "header" part <code>&lt;&lt;fura.h&gt;&gt;</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orga1db6e4">&lt;&lt;ts-type-definition&gt;&gt;

&lt;&lt;ts_vector-type-definition&gt;&gt;

ts * ts_alloc(size_t n_obs);

int ts_free(ts * pts);

int ts_fprintf(FILE * stream, ts * pts);

ts_vector * ts_vector_alloc(size_t nelt);

int ts_vector_free(ts_vector * pts_vector);

int ts_vector_fprintf(FILE * stream, ts_vector * pts_vector);

ts_vector * fura_est(aba * paba);
</pre>
</div>

<p>
Next, the function definitions <code>&lt;&lt;fura.c&gt;&gt;</code> stored in file <code>code/fura.c</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgb27031d">/** \file fura.c
    \brief Function definitions for [Fura] related calculations
 */
#include "abaa.h"

&lt;&lt;ts_alloc&gt;&gt;

&lt;&lt;ts_free&gt;&gt;

&lt;&lt;ts_fprintf&gt;&gt;

&lt;&lt;ts_vector_alloc&gt;&gt;

&lt;&lt;ts_vector_free&gt;&gt;

&lt;&lt;ts_vector_fprintf&gt;&gt;

&lt;&lt;fura_est&gt;&gt;
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgba7f560" class="outline-2">
<h2 id="orgba7f560"><span class="section-number-2">3</span> Working the ratiometric estimator</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgee10be2" class="outline-3">
<h3 id="orgee10be2"><span class="section-number-3">3.1</span> Some analytical details</h3>
<div class="outline-text-3" id="text-3-1">
<p>
We keep going with the definition of functions allowing us to work with the "classical" ratiometric estimator that we write, at time \(t_i\), as <a href="http://jn.physiology.org/content/103/2/1130">Joucla et al (2010), Eq. 8, p. 1133</a>:
</p>

\begin{equation}
\widehat{Ca}(t_i) = K_{eff} \, \frac{r(t_i)-R_{min}}{R_{max}-r(t_i)} \, , \label{eq:RatiometricEstimator}
\end{equation}
<p>
where \(K_{eff}\), \(R_{min}\) and \(R_{max}\) are calibrated parameters (assumed exactly known for now) and where <a href="http://jn.physiology.org/content/103/2/1130">Joucla et al (2010), Eq. 6, p. 1133</a>:
</p>
\begin{equation}
r(t_i) = \frac{\left(P\,T_{e,340}\,G\right)^{-1}\, ADU_{340} - s_{B,340}}{\left(P\,T_{e,380}\,G\right)^{-1}\, ADU_{380} - s_{B,380}} \, , \label{eq:ADUratio}
\end{equation}
<p>
where the auto-fluorescence \(s_{B,340}\) and \(s_{B,380}\) are also assumed known for now. Our model for the fluorescence intensity at each wavelength is  <a href="http://jn.physiology.org/content/103/2/1130">Joucla et al (2010), Eq. 2a and 2b</a>:
</p>
\begin{equation}
F_{340} =  \left\{\frac{[Fura]_{total}\, \phi}{K_{Fura}+[Ca^{2+}]}\left(R_{min}\, K_{eff} + R_{max} [Ca^{2+}]\right) + s_{B,340}\right\} \, T_{e,340} \, P \, , \label{eq:F340}
\end{equation}
<p>
and
</p>
\begin{equation}
F_{380} =  \left\{\frac{[Fura]_{total}\, \phi}{K_{Fura}+[Ca^{2+}]}\left(K_{eff} + [Ca^{2+}]\right) + s_{B,380}\right\} \, T_{e,380} \, P  \, , \label{eq:F380}
\end{equation}
<p>
where \(K_{Fura}\) is a calibrated
parameter, \(P\) is the number of pixels of the region of interest
(<code>ROI</code>), \(T_{e,\lambda}\) is the exposure time at wavelength \(\lambda\),
\(s_{B,\lambda}\) is the auto-fluorescence at wavelength
\(\lambda\) &#x2013;assumed homogeneous among the \(P\) pixels of the ROI&#x2013;,
\([Fura]_{total}\, \phi\), is the total (bound plus free) concentration of
Fura in the cell multiplied by a dimensionless experiment specific
parameter, \(\phi\), lumping together the quantum efficiency, the neurite
thickness, etc.
</p>

<p>
Under our assumptions (see the slide 56 of <a href="https://zenodo.org/record/18691">my lecture</a>) we have:
</p>
\begin{equation}
ADU_{\lambda}(t_i) = G\, F_{\lambda}(t_i) + \epsilon \, G\, \sqrt{F_{\lambda}(t_i) + \sigma^2_{read-out}}  \, , \label{eq:ADUdist}
\end{equation}
<p>
where \(F_{\lambda}(t_i)\) is given by Eq. \ref{eq:F340} and \ref{eq:F380} and where \(\epsilon \sim \mathcal{N}(0,1)\) (\(\epsilon\) is a Gaussian random variable with mean 0 and variance 1). In words: \(ADU_{\lambda}(t_i)\) has a Gaussian distribution with mean \(G\, F_{\lambda}(t_i)\) and variance \(G^2\, \left(F_{\lambda}(t_i) + \sigma^2_{read-out}\right)\).
</p>

<p>
So, to have the variance of \(ADU_{\lambda}(t_i)\) we need to know \(F_{\lambda}(t_i)\) and for that we need to know \(Ca(t_i)\) precisely what we want to estimate&#x2026; But since \(\mathrm{E}ADU_{\lambda}(t_i)\) (the expected value) is \(G\, F_{\lambda}(t_i)\) we can use the observed value \(\widehat{ADU}_{\lambda}(t_i)\) of \(ADU_{\lambda}(t_i)\) as a guess for \(G\, F_{\lambda}(t_i)\) leading to:
</p>

\begin{equation}
\hat{\sigma}^2_{ADU_{\lambda}(t_i)} = G\, \widehat{ADU}_{\lambda}(t_i) + G^2\, \sigma^2_{read-out} \approx \sigma^2_{ADU_{\lambda}(t_i)} \, . \label{eq:ADUapproxVar}
\end{equation}  

<p>
Now that we have a \(\hat{\sigma}^2_{ADU_{\lambda}(t_i)}\) we can work with, we want to get \(\hat{\sigma}^2_{r(t_i)}\) and \(\hat{\sigma}^2_{\widehat{Ca}(t_i)}\). We could use the <a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty">propagation of uncertainty</a> (or error propagation) together with Eq. \ref{eq:ADUratio} and \ref{eq:RatiometricEstimator} for that (and I will do it at some point), but now we will use a "quick and dirty" Monte Carlo approach. We will draw a thousand pair of vectors \(\left(ADU_{340}^{[j]}(t_i),ADU_{380}^{[j]}(t_i)\right)\) (\(j=1,\ldots,1000\)) from two independent Gaussian distributions:  
</p>

\begin{equation}\label{eq:ADUapproxVarMC}
ADU_{\lambda}^{[j]}(t_i) = ADU_{\lambda}(t_i) + \epsilon_{j} \, \hat{\sigma}_{ADU_{\lambda}(t_i)}\, ,
\end{equation}

<p>
plug-in these pairs into Eq. \ref{eq:ADUratio} giving us 1000 \(r^{[j]}(t_i)\) before plugging in the latter into Eq. \ref{eq:RatiometricEstimator} leading to 1000 \(\widehat{Ca}^{[j]}(t_i)\). The empirical variance of these observation will be used as \(\hat{\sigma}^2_{\widehat{Ca}(t_i)}\).
</p>
</div>
</div>

<div id="outline-container-orgac5bb72" class="outline-3">
<h3 id="orgac5bb72"><span class="section-number-3">3.2</span> Goodness of fit functions definitions</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Having a standard error for our ratiometric estimator (or at least an estimated standard error) gives us a yardstick for measuring the distance between observed data and a fitted model like a mono-exponential relaxation. When we fit a mono-exponential relaxation to a transient, the normalized residuals&#x2013;that is the difference between individual observations and their fitted values <i>divided by the standard error of the observations</i>&#x2013;should (almost) follow a standard normal distribution (a normal distribution with mean 0 and variance 1)&#x2013;I write almost because the model parameters have been fitted from the same data&#x2013;. We can therefore check if the residual follow this theoretical standard normal distribution both with a formal test like an Anderson-Darling test and with a quantile-quantile plot. We can also check if the residual sum of squares follows a \(\chi^2\) distribution with the proper number of degrees of freedom (the number of observed values minus the number of fitted parameters). We should also check that the residuals do not exhibit any autocorrelation (they should be identically and <i>independently</i> drawn), we can check that with a graph of the empirical autocorrelation function of the residuals and with a formal test. We define next a few functions that perform these tests.
</p>
</div>

<div id="outline-container-orgb372213" class="outline-4">
<h4 id="orgb372213"><span class="section-number-4">3.2.1</span> <code>C</code> code doing the tests</h4>
<div class="outline-text-4" id="text-3-2-1">
</div>
<div id="outline-container-org2958633" class="outline-5">
<h5 id="org2958633"><span class="section-number-5">3.2.1.1</span> <code>AndersonDarling_W2</code> definition</h5>
<div class="outline-text-5" id="text-3-2-1-1">
<div class="org-src-container">
<pre class="src src-C" id="org1cb4b10">/** @brief Returns the Anderson-Darling statistics assuming a
 *  standard normal distribution for the data
 *
 *  The data are contained in the `gsl_vector` pointed to
 *  by `data`. If the content is not sorted (`sorted==false`)
 *  the data are first copied before being sorted.
 *
 *  @param[in] data pointer to a `gsl_vector` containing the data
 *  @param[in] sorted a boolean indicated if the `data` content is
 *             already sorted (`true`) or not (`false`)
 *  @returns a double with the Anderson-Darling statistics
*/
double AndersonDarling_W2(gsl_vector * data, bool sorted)
{
  gsl_vector * data_s;
  if (sorted == false)
  {
    data_s = gsl_vector_alloc(data-&gt;size);
    gsl_vector_memcpy(data_s,data);
    gsl_sort_vector(data_s);
  }
  else
  {
    data_s = data;
  }
  size_t n = data-&gt;size;
  double n_d = (double) n;
  double A=0.;
  for (size_t i=1; i&lt;=n; i++)
  {
    double y = gsl_vector_get(data_s,i-1);
    double Phi_at_y = gsl_cdf_gaussian_P(y,1.0);
    A += (2*i-1.)*log(Phi_at_y)+(2*(n_d-i)+1)*log(1-Phi_at_y);
  }
  A /= -n_d;
  if (sorted == false)
    gsl_vector_free(data_s);
  return A-n_d;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org62629f8" class="outline-5">
<h5 id="org62629f8"><span class="section-number-5">3.2.1.2</span> <code>adinf</code> definition</h5>
<div class="outline-text-5" id="text-3-2-1-2">
<p>
This function returns the asymptotic value of the Anderson-Darling distribution. It is adapted from Marsaglia and Marsaglia (2004) <a href="https://www.jstatsoft.org/article/view/v009i02">Evaluating the Anderson-Darling Distribution</a>.
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgf53faac">/** @brief Returns the asymptotic cdf of the Anderson-Darling
    statistics.
 *
 *  Adaptation of function `adinf` of Marsaglia &amp; Marsaglia (2004)
 *  [J. Stat. Software 9(2): 1-5](https://www.jstatsoft.org/article/view/v009i02).
 *
 *  @param[in] z a double the observed statistics value
 *  @returns a double Prob{W2 &lt;= z}
*/
double adinf(double z)
{
  if(z&lt;2.)
    return exp(-1.2337141/z)/sqrt(z)*(2.00012+(.247105-(.0649821-(.0347962-(.011672-.00168691*z)*z)*z)*z)*z);
  /* max |error| &lt; .000002 for z&lt;2, (p=.90816...) */
 return exp(-exp(1.0776-(2.30695-(.43424-(.082433-(.008056 -.0003146*z)*z)*z)*z)*z));
 /* max |error|&lt;.0000008 for 4&lt;z&lt;infinity */
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org18bd7b8" class="outline-5">
<h5 id="org18bd7b8"><span class="section-number-5">3.2.1.3</span> <code>AD_cdf_P</code> definition</h5>
<div class="outline-text-5" id="text-3-2-1-3">
<p>
This function returns Pr{W2 &lt;= z}, where W2 is the Anderson-Darling statistics, using a correction for finite sample size, see Marsaglia and Marsaglia (2004) <a href="https://www.jstatsoft.org/article/view/v009i02">Evaluating the Anderson-Darling Distribution</a>.
</p>

<div class="org-src-container">
<pre class="src src-C" id="org5d070e1">/** @brief Returns the finite sample cdf of the Anderson-Darling
    statistics.
 
   Adaptation of function `AD` of Marsaglia &amp; Marsaglia (2004)
   [J. Stat. Software 9(2): 1-5](https://www.jstatsoft.org/article/view/v009i02).
 
   @param[in] n an integer with the sample size
   @param[in] z a double the observed statistics value
   @returns a double Prob{W2 &lt;= z}
*/
double AD_cdf_P(int n,double z)
{
  double v;
  double x=adinf(z);
  if(x&gt;.8)
  {
    v=(-130.2137+(745.2337-(1705.091-(1950.646-(1116.360-255.7844*x)*x)*x)*x)*x)/n;
    return x+v;
  }
  double c=.01265+.1757/n;
  if(x&lt;c)
  {
    v=x/c;
    v=sqrt(v)*(1.-v)*(49*v-102);
    return x+v*(.0037/(n*n)+.00078/n+.00006)/n;
  }
  v=(x-c)/(.8-c);
  v=-.00022633+(6.54034-(14.6538-(14.458-(8.259-1.91864*v)*v)*v)*v)*v;
  return x+v*(.04213+.01365/n)/n;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf1b6410" class="outline-4">
<h4 id="orgf1b6410"><span class="section-number-4">3.2.2</span> <code>gof</code> header, source and test</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
The header part in code block <code>&lt;&lt;gof.h&gt;&gt;</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org7cfca67">double AndersonDarling_W2(gsl_vector * data, bool sorted);
double aspa_adinf(double z);
double AD_cdf_P(int n,double z);
</pre>
</div>

<p>
The function definitions <code>&lt;&lt;gof.c&gt;&gt;</code> stored in file <code>code/gof.c</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org20596ac">/** \file gof.c
    \brief Functions defining goodness of fit tests.
 */

&lt;&lt;AndersonDarling_W2&gt;&gt;

&lt;&lt;adinf&gt;&gt;

&lt;&lt;AD_cdf_P&gt;&gt;
</pre>
</div>

<p>
We define next a program testing the goodness of fit functions
</p>

<div class="org-src-container">
<pre class="src src-C" id="org6f09040">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;gsl/gsl_math.h&gt;
#include &lt;gsl/gsl_vector.h&gt;
#include &lt;gsl/gsl_rng.h&gt;
#include &lt;gsl/gsl_randist.h&gt;
#include &lt;gsl/gsl_cdf.h&gt;
#include &lt;gsl/gsl_sort.h&gt;
#include &lt;gsl/gsl_sort_vector.h&gt;

&lt;&lt;AndersonDarling_W2&gt;&gt;

&lt;&lt;adinf&gt;&gt;

&lt;&lt;AD_cdf_P&gt;&gt;

int main()
{
  gsl_rng * r;
  const gsl_rng_type * T;
  gsl_rng_env_setup();
  T = gsl_rng_default;
  r = gsl_rng_alloc (T);
  
  double w90 = 1.93295783274159;
  double w95 = 2.4923671600494096;
  double w99 = 3.8781250216053948;

  printf("********************************************************\n");
  printf("Test asymptotic cdf using Marsaglia &amp; Marsaglia values:\n");
  printf("Pr(W2 &lt; 1.93295783274159) = %g, the theoretical value is 0.90\n", adinf(w90));
  printf("Pr(W2 &lt; 2.4923671600494096) = %g, the theoretical value is 0.95\n", adinf(w95));
  printf("Pr(W2 &lt; 3.8781250216053948) = %g, the theoretical value is 0.99\n", adinf(w99));
  printf("\n");
  printf("Generating a sample of size 100 with Box-Müller (mean 0 and var 1)\n");
  gsl_vector * sample = gsl_vector_alloc(100);
  for (size_t i=0; i &lt; sample-&gt;size; i++)
    gsl_vector_set(sample,i,gsl_ran_gaussian(r,1.0));
  double W2 = AndersonDarling_W2(sample,false);
  printf("The Anderson-Darling statistics, W2, value is: %g\n", W2);
  printf("Prob(W2 &lt;= %g) = %g\n",W2, AD_cdf_P(sample-&gt;size,W2));
  gsl_vector_free(sample);
  printf("Generating a sample of size 750 with the ratio of uniforms (mean 0 and var 1)\n");
  sample = gsl_vector_alloc(750);
  for (size_t i=0; i &lt; sample-&gt;size; i++)
    gsl_vector_set(sample,i,gsl_ran_ugaussian_ratio_method(r));
  W2 = AndersonDarling_W2(sample,false);
  printf("The Anderson-Darling statistics, W2, value is: %g\n", W2);
  printf("Prob(W2 &lt;= %g) = %g\n",W2, AD_cdf_P(sample-&gt;size,W2));
  gsl_vector_free(sample);
  printf("Generating a sample of size 500 with the ziggurat (mean 0 and var 1.2)\n");
  sample = gsl_vector_alloc(500);
  for (size_t i=0; i &lt; sample-&gt;size; i++)
    gsl_vector_set(sample,i,gsl_ran_gaussian_ziggurat(r, 1.2));
  W2 = AndersonDarling_W2(sample,false);
  printf("The Anderson-Darling statistics, W2, value is: %g\n", W2);
  printf("Prob(W2 &lt;= %g) = %g\n",W2, AD_cdf_P(sample-&gt;size,W2));
  printf("\n");
  printf("Generating now 10,000 samples of size 100 form a standard normal with the ziggurat\n");
  printf("method and computing the cdf of the W2 statistics...\n");
  double W2_cdf_sample[10000];
  sample = gsl_vector_alloc(100);
  for (size_t rep=0; rep &lt; 10000; rep++) {
    for (size_t i=0; i &lt; sample-&gt;size; i++)
      gsl_vector_set(sample,i,gsl_ran_gaussian_ziggurat(r, 1.0));
    W2_cdf_sample[rep] = AD_cdf_P(sample-&gt;size,AndersonDarling_W2(sample,false));
  }
  gsl_vector_free(sample);
  gsl_sort(W2_cdf_sample,1,10000);
  double decile[9];
  printf("The theoretical deciles of the cdf of the W2 statistics are:\n");
  printf("0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9.\n");
  printf("The empirical deciles of the cdf of the W2 statistics are:\n");
  for (size_t i=0; i &lt; 9; i++) 
    decile[i] = W2_cdf_sample[(i+1)*1000-1];
  printf("%g, %g, %g, %g, %g, %g, %g, %g, %g.\n", decile[0],
    decile[1],decile[2],decile[3],decile[4],decile[5],decile[6],
    decile[7],decile[8]);
  printf("\n");
  printf("Generating now 10,000 samples of size 100 form a normal(0,1.05) with the ziggurat\n");
  printf("method and computing the cdf of the W2 statistics...\n");
  sample = gsl_vector_alloc(100);
  for (size_t rep=0; rep &lt; 10000; rep++) {
    for (size_t i=0; i &lt; sample-&gt;size; i++)
      gsl_vector_set(sample,i,gsl_ran_gaussian_ziggurat(r, 1.05));
    W2_cdf_sample[rep] = AD_cdf_P(sample-&gt;size,AndersonDarling_W2(sample,false));
  }
  gsl_vector_free(sample);
  gsl_sort(W2_cdf_sample,1,10000);
  printf("The deciles of the cdf of the W2 statistics are:\n");
  for (size_t i=0; i &lt; 9; i++) 
    decile[i] = W2_cdf_sample[(i+1)*1000-1];
  printf("%g, %g, %g, %g, %g, %g, %g, %g, %g\n", decile[0],
    decile[1],decile[2],decile[3],decile[4],decile[5],decile[6],
    decile[7],decile[8]);
  printf("********************************************************\n");
  printf("\n");
  
  gsl_rng_free(r);
  
}
</pre>
</div>

<p>
We compile the code with
</p>

<div class="org-src-container">
<pre class="src src-shell" id="org9d8d39a">gcc -Wall -g -o code/gof_test code/gof_test.c -lgsl -lgslcblas -lm -std=gnu11
</pre>
</div>

<p>
We run it with:
</p>

<div class="org-src-container">
<pre class="src src-shell" id="org4c2ff6f">./code/gof_test
</pre>
</div>

<pre class="example">
********************************************************
Test asymptotic cdf using Marsaglia &amp; Marsaglia values:
Pr(W2 &lt; 1.93295783274159) = 0.899989, the theoretical value is 0.90
Pr(W2 &lt; 2.4923671600494096) = 0.950008, the theoretical value is 0.95
Pr(W2 &lt; 3.8781250216053948) = 0.989997, the theoretical value is 0.99

Generating a sample of size 100 with Box-Müller (mean 0 and var 1)
The Anderson-Darling statistics, W2, value is: 0.889134
Prob(W2 &lt;= 0.889134) = 0.579274
Generating a sample of size 750 with the ratio of uniforms (mean 0 and var 1)
The Anderson-Darling statistics, W2, value is: 0.500623
Prob(W2 &lt;= 0.500623) = 0.253873
Generating a sample of size 500 with the ziggurat (mean 0 and var 1.2)
The Anderson-Darling statistics, W2, value is: 6.32691
Prob(W2 &lt;= 6.32691) = 0.999319

Generating now 10,000 samples of size 100 form a standard normal with the ziggurat
method and computing the cdf of the W2 statistics...
The theoretical deciles of the cdf of the W2 statistics are:
0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9.
The empirical deciles of the cdf of the W2 statistics are:
0.104977, 0.201766, 0.299999, 0.401884, 0.505917, 0.606301, 0.701158, 0.796981, 0.900323.

Generating now 10,000 samples of size 100 form a normal(0,1.05) with the ziggurat
method and computing the cdf of the W2 statistics...
The deciles of the cdf of the W2 statistics are:
0.12197, 0.247288, 0.363748, 0.469283, 0.573063, 0.675121, 0.765229, 0.850781, 0.929011
********************************************************

</pre>
</div>
</div>
</div>



<div id="outline-container-org6cbfbf9" class="outline-3">
<h3 id="org6cbfbf9"><span class="section-number-3">3.3</span> <code>ratio</code> structure and related functions</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Our <code>C</code> code is going to use a structure akin to the <a href="#org07829d3">adu structure</a> to store its ratiometric estimates. A bunch a functions are going to be associated with this structure.
</p>
</div>

<div id="outline-container-org3a0bbf1" class="outline-4">
<h4 id="org3a0bbf1"><span class="section-number-4">3.3.1</span> <code>C</code> code related to <code>ratio</code> structures</h4>
<div class="outline-text-4" id="text-3-3-1">
</div>
<div id="outline-container-org456e0c3" class="outline-5">
<h5 id="org456e0c3"><span class="section-number-5">3.3.1.1</span> <code>ratio</code> type definition</h5>
<div class="outline-text-5" id="text-3-3-1-1">
<div class="org-src-container">
<pre class="src src-C" id="orge4e7602">/** \struct ratio
 *  \brief Structure holding arrays of gsl_vectors each vector contains
 *         ratiometric estimates.
*/
typedef struct
{
  gsl_vector * RATIO; //!&lt; ratiometric estimator
  gsl_vector * RATIO_SE; //!&lt; standard error of RATIO
  gsl_vector * TIME; //!&lt; time (in s) of measurements
} ratio;
</pre>
</div>
</div>
</div>

<div id="outline-container-org61d874c" class="outline-5">
<h5 id="org61d874c"><span class="section-number-5">3.3.1.2</span> <code>ratio_alloc</code>  definition</h5>
<div class="outline-text-5" id="text-3-3-1-2">
<p>
It will be helpful to have an <code>alloc</code> function for <code>ratio</code> structures:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org19bd603">/** \fn ratio * ratio_alloc(size_t n_obs)
    \brief Allocates a [ratio](@ref ratio) structure
 
    The function allocates memory for an [ratio](@ref ratio) structure
 
    \param[in] n_obs the number of measurements / obserations 
    \returns a pointer to an allocated ratio
*/
ratio * ratio_alloc(size_t n_obs) {
  ratio * res = malloc(sizeof(ratio));
  res-&gt;RATIO = gsl_vector_alloc(n_obs);
  res-&gt;RATIO_SE = gsl_vector_alloc(n_obs);
  res-&gt;TIME = gsl_vector_alloc(n_obs);
  return res;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org75b3062" class="outline-5">
<h5 id="org75b3062"><span class="section-number-5">3.3.1.3</span> <code>ratio_free</code> definition</h5>
<div class="outline-text-5" id="text-3-3-1-3">
<p>
It will also be helpful to have a <code>free</code> function for <code>ratio</code> structures:
</p>
<div class="org-src-container">
<pre class="src src-C" id="org89fea84">/** \fn int ratio_free(ratio * ratio_ptr)
    \brief Frees a [ratio](@ref ratio) structure
 
    \param ratio_ptr a pointer to an allocated [ratio](@ref ratio) structure
    \returns 0 if everything goes fine 
*/
int ratio_free(ratio * ratio_ptr) {
  gsl_vector_free(ratio_ptr-&gt;RATIO);
  gsl_vector_free(ratio_ptr-&gt;RATIO_SE);
  gsl_vector_free(ratio_ptr-&gt;TIME);
  free(ratio_ptr);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org776af6b" class="outline-5">
<h5 id="org776af6b"><span class="section-number-5">3.3.1.4</span> <code>ratio_get_set</code> macro definitions</h5>
<div class="outline-text-5" id="text-3-3-1-4">
<p>
We define next <code>macros</code> with arguments giving an easy way to get and set values of specific members of <code>ratio</code> structure:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org10ec34d">/** \def ratio_get(ratio,member,i)
    \brief A macro that returns value at index \a i of
           member \a member from \a [ratio](@ref ratio) structure 
*/
#define ratio_get(ratio,member,i) gsl_vector_get(ratio-&gt;member,i)
/** \def ratio_set(ratio,member,i,x)
    \brief A macro that sets value at index \a i of
           member \a member from \a [ratio](@ref ratio) structure at \a x 
*/
#define ratio_set(ratio,member,i,x) gsl_vector_set(ratio-&gt;member,i,x)
</pre>
</div>
</div>
</div>

<div id="outline-container-org7044468" class="outline-5">
<h5 id="org7044468"><span class="section-number-5">3.3.1.5</span> <code>ratio_fprintf</code> definition</h5>
<div class="outline-text-5" id="text-3-3-1-5">
<p>
We now define a function that prints to the <code>stdout</code> the content of an <code>ratio</code> structure:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgf9f5446">/** \fn int ratio_fprintf(FILE* fp, ratio * pratio)
    \brief Prints [ratio](@ref ratio) content to fp
 
    \param[in] fp file pointer
    \param[in] pratio a pointer to a [ratio](@ref ratio) structure
    \return 0 if everything goes fine
*/
int ratio_fprintf(FILE* fp, ratio * pratio) {
  size_t nobs=(pratio)-&gt;TIME-&gt;size;
  fprintf(fp,"# Ratiometric estimator:\n");
  fprintf(fp,"#    Time    Ca (est)    Ca (se)\n");
  for (size_t i=0; i&lt;nobs; i++) {
    double time = ratio_get((pratio),TIME,i);
    double ratio = ratio_get((pratio),RATIO,i);
    double ratio_se = ratio_get((pratio),RATIO_SE,i);
    fprintf(fp,"%9.9g %9.9g %9.9g\n",
	   time, ratio, ratio_se);
  }
  fprintf(fp,"\n\n");
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf748aaa" class="outline-5">
<h5 id="orgf748aaa"><span class="section-number-5">3.3.1.6</span> <code>ratio_est</code></h5>
<div class="outline-text-5" id="text-3-3-1-6">
<p>
We now define the only function doing "interesting" work, <code>ratio_est</code>, that does the computations leading to the ratiometric estimation and is standard error.
</p>

<div class="org-src-container">
<pre class="src src-C" id="org97bcb46">/** \fn ratio * ratio_est(adu * padu, dye * pdye, illumination * plight, ccd * pccd, size_t nrep)
    \brief Computes ratiometric estimator and estimates its standard error

    \param[in] padu a pointer to an [adu](@ref adu) structure
    \param[in] pdye a pointer to a [dye](@ref dye) structure
    \param[in] plight a pointer to an [illumination](@ref illumination) structure
    \param[in] nrep the number of replicates used in the MC estimation of the SE
    \return a pointer to an initialized [ratio](@ref ratio) structure
 */
ratio * ratio_est(adu * padu,
		  dye * pdye,
		  illumination * plight,
		  ccd * pccd,
		  size_t nrep)
{
  // get the dye parameters
  double Rmin = pdye-&gt;R_min_hat;
  double Rmax = pdye-&gt;R_max_hat;
  double Keff = pdye-&gt;K_eff_hat;
  // get the illumination parameters
  double T340 = plight-&gt;T_340;
  double T380 = plight-&gt;T_380;
  // get the CCD chip parameters
  double nP = (double) pccd-&gt;P;
  double nPB = (double) pccd-&gt;P_B;

  // macro that returns the "ratio"
#define R(ADU340,ADU340B,ADU380,ADU380B)			\
  ((ADU340/nP)-(ADU340B/nPB))*T380/\
  ((ADU380/nP)-(ADU380B/nPB))/T340
  // macro the returns the estimated free [Ca2+]
  // for a given "ratio"
#define Ca(r) Keff*(r-Rmin)/(Rmax-r)

  const gsl_rng_type * T = gsl_rng_default;
  gsl_rng_env_setup();
  gsl_rng * rng = gsl_rng_alloc (T);
  size_t nobs = (padu)-&gt;TIME-&gt;size;
  ratio * res = ratio_alloc(nobs);
  // do the MC standard error estimation
  for (size_t i=0; i&lt;nobs; i++) {
    double adu340 = adu_get(padu,ADU340,i);
    double adu340B = adu_get(padu,ADU340B,i);
    double adu380 = adu_get(padu,ADU380,i);
    double adu380B = adu_get(padu,ADU380B,i);
    double r = R(adu340,adu340B,adu380,adu380B);
    ratio_set(res,TIME,i,adu_get(padu,TIME,i));
    ratio_set(res,RATIO,i,Ca(r));
    double g = pccd-&gt;gain;
    double s2 = g*g*nP*pccd-&gt;s2;
    double s2B = g*g*nPB*pccd-&gt;s2;
    double Ca_rep[nrep];
    for (size_t j=0; j&lt;nrep; j++) {
      double adu340r = adu340+gsl_ran_gaussian_ziggurat(rng,sqrt(g*adu340+s2));
      double adu340Br = adu340B+gsl_ran_gaussian_ziggurat(rng,sqrt(g*adu340B+s2B));
      double adu380r = adu380+gsl_ran_gaussian_ziggurat(rng,sqrt(g*adu380+s2));
      double adu380Br = adu380B+gsl_ran_gaussian_ziggurat(rng,sqrt(g*adu380B+s2B));
      r = R(adu340r,adu340Br,adu380r,adu380Br);
      Ca_rep[j] = Ca(r);
    }
    ratio_set(res,RATIO_SE,i,gsl_stats_sd(Ca_rep,1,nrep));
  }
  gsl_rng_free (rng);
  return res;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb4111e9" class="outline-5">
<h5 id="orgb4111e9"><span class="section-number-5">3.3.1.7</span> <code>ratio_find_fit_start</code></h5>
<div class="outline-text-5" id="text-3-3-1-7">
<p>
Function <code>ratio_find_fit_start</code> locates the first point whose amplitude is smaller than the baseline plus a fraction of the stimulation induced jump.
</p>

<div class="org-src-container">
<pre class="src src-C" id="org9c27c32">/** \fn size_t ratio_find_fit_start(ratio * pratio, double remaining_fraction, size_t baseline)
    \brief Locates the first point of a transient whose amplitude is smaller than the baseline 
    plus a fraction of the stimulation induced jump.
    
    \param[in] pratio a pointer to an initialized [ratio](@ref ratio) structure
    \param[in] remaining_fraction the remaining fraction of the jump amplitude
    from which to start
    \param[in] baseline the length (in sample points) of the baseline
    \return a `size_t` with the searched location 
 */
size_t ratio_find_fit_start(ratio * pratio, double remaining_fraction, size_t baseline)
{
  double baseline_mean = 0.0;
  for (size_t i=0; i&lt;baseline; i++)
    baseline_mean += gsl_vector_get(pratio-&gt;RATIO,i);
  baseline_mean /= baseline;
  size_t max_idx = gsl_vector_max_index(pratio-&gt;RATIO);
  double DeltaCa = gsl_vector_get(pratio-&gt;RATIO,max_idx)-baseline_mean;
  double threshold = DeltaCa*remaining_fraction+baseline_mean;
  size_t i=max_idx+1;
  while ((gsl_vector_get(pratio-&gt;RATIO,i) &gt; threshold) &amp; (i &lt; pratio-&gt;RATIO-&gt;size))
    i++;
  return i;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfa63195" class="outline-5">
<h5 id="orgfa63195"><span class="section-number-5">3.3.1.8</span> <code>mono_exp_fit_res</code></h5>
<div class="outline-text-5" id="text-3-3-1-8">
<p>
We define a structure holding results of a mono-exponential fit.
</p>

<div class="org-src-container">
<pre class="src src-C" id="org239df92">/** \struct mono_exp_fit_res
    \brief Structure holding result of a mono-exponential
    fit Y = baseline + delta * exp(-(t-t0)/tau)
 
    Depending on the input data the nonlinear least-squares
    can be weighted. That's the case when working with the
    ratiometric estimator.
 */
typedef struct
{
  size_t nobs; //!&lt; number of observation used for the fit
  size_t baseline_length; //!&lt; length of baseline region
  size_t fit_start; //!&lt; first point used for the fit
  double baseline; //!&lt; fitted baseline value
  double baseline_se; //!&lt; standard error of the baseline
  double delta; //!&lt; fitted jump amplitude
  double delta_se; //!&lt; standard error of delta
  double tau; //!&lt; fitted time constant
  double tau_se; //!&lt; standard error of tau
  double rss; //!&lt; RSS value
  int status; //!&lt; solver's status when fit stops
} mono_exp_fit_res;
</pre>
</div>
</div>
</div>

<div id="outline-container-org9ce3c85" class="outline-5">
<h5 id="org9ce3c85"><span class="section-number-5">3.3.1.9</span> <code>mono_exp_fit_res_fprintf</code></h5>
<div class="outline-text-5" id="text-3-3-1-9">
<p>
This function prints the structure content to a file (or the <code>stdout</code>).
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgb6b46b7">/** \fn int mono_exp_fit_res_fprintf(FILE * fp, mono_exp_fit_res * str, ratio * pratio)
    \brief Prints content of a [mono_exp_fit_res](@ref mono_exp_fit_res) structure 
    together with the fitted data

    \param[in] fp pointer to the file where printing is performed
    \param[in] str pointer to the [mono_exp_fit_res](@ref mono_exp_fit_res) 
    structure to print
    \param[in] pratio pointer to a [ratio](@ref ratio) structure containing
    the fitted data
    \returns 0 if everything goes fine
 */
int mono_exp_fit_res_fprintf(FILE * fp, mono_exp_fit_res * str, ratio * pratio)
{
  fprintf(fp,"# Fitted model Ca = baseline+delta*exp(-(t-t0)/tau)\n");
  fprintf(fp,"# nobs = %d\n", (int) str-&gt;nobs);
  fprintf(fp,"# number of degrees of freedom = %d\n", ((int) str-&gt;nobs)-3);
  fprintf(fp,"# baseline length = %d\n", (int) str-&gt;baseline_length);
  fprintf(fp,"# fit started from point %d\n", (int) str-&gt;fit_start);
  fprintf(fp,"# estimated baseline %g and standard error %g\n", str-&gt;baseline,str-&gt;baseline_se);
  fprintf(fp,"# estimated delta %g and standard error %g\n", str-&gt;delta,str-&gt;delta_se);
  fprintf(fp,"# estimated tau %g and standard error %g\n", str-&gt;tau,str-&gt;tau_se);
  fprintf(fp,"# residual sum of squares: %g\n", str-&gt;rss);
  double dof = (((double) str-&gt;nobs)-3.0);
  fprintf(fp,"# RSS per degree of freedom: %g\n", str-&gt;rss/dof);
  double p_larger = gsl_cdf_chisq_Q(str-&gt;rss,dof);
  fprintf(fp,"# Probability of observing a larger of equal RSS per DOF under the null hypothesis: %g\n",p_larger);
  if (p_larger &lt; 0.01)
    fprintf(fp,"# WARNING: THE FIT IS NOT GOOD!\n");
  fprintf(fp,"\n");
  fprintf(fp,"# rss per degree of freedom: %g\n\n", str-&gt;rss/(((double) str-&gt;nobs)-3.0));
  fprintf(fp,"# Time    Ca  Prediction  Residual\n");
  for (size_t i=0; i&lt;str-&gt;baseline_length; i++) {
    double time = gsl_vector_get(pratio-&gt;TIME,i);
    double y = gsl_vector_get(pratio-&gt;RATIO,i);
    double pred = str-&gt;baseline;
    double resid = (y-pred)/gsl_vector_get(pratio-&gt;RATIO_SE,i);
    fprintf(fp,"%g %g %g %g\n",time,y,pred,resid);
  }
  fprintf(fp,"\n");
  double t0 = gsl_vector_get(pratio-&gt;TIME,str-&gt;fit_start);
  for (size_t i=str-&gt;fit_start; i&lt;pratio-&gt;TIME-&gt;size; i++) {
    double time = gsl_vector_get(pratio-&gt;TIME,i);
    double dt = time-t0;
    double y = gsl_vector_get(pratio-&gt;RATIO,i);
    double pred = str-&gt;baseline;
    pred += str-&gt;delta*exp(-dt/str-&gt;tau);
    double resid = (y-pred)/gsl_vector_get(pratio-&gt;RATIO_SE,i);
    fprintf(fp,"%g %g %g %g\n",time,y,pred,resid);
  }
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org08f3d43" class="outline-5">
<h5 id="org08f3d43"><span class="section-number-5">3.3.1.10</span> <code>ratio_for_fit</code></h5>
<div class="outline-text-5" id="text-3-3-1-10">
<p>
We define a specific structure suitable for fitting a mono-exponential decay to ratio metric estimates stored in a <code>ratio</code> structure:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org672d318">/** \struct ratio_for_fit
    \brief Structure suitable for fitting a mono-exponential decay to 
    the ratio metric estimates stored in a [ratio](@ref ratio) structure 
 */
typedef struct
{
  size_t i0; //!&lt; index at which the decay fit starts
  size_t baseline_length; //!&lt; baseline length
  ratio * pratio; //!&lt; pointer to a ratio structure
} ratio_for_fit;
</pre>
</div>
</div>
</div>

<div id="outline-container-org20c7220" class="outline-5">
<h5 id="org20c7220"><span class="section-number-5">3.3.1.11</span> <code>ratio_residuals</code></h5>
<div class="outline-text-5" id="text-3-3-1-11">
<p>
We define a function returning the (weighted) residuals of a mono-exponential fit suitable for use with the <code>gsl</code> <a href="https://www.gnu.org/software/gsl/manual/html_node/Nonlinear-Least_002dSquares-Exponential-Fit-Example.html#Nonlinear-Least_002dSquares-Exponential-Fit-Example">nonlinear least-squares solver</a>.
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgd795576">/** \fn int ratio_residuals (const gsl_vector * x, void *data, gsl_vector * f)
    \brief Returns the (weighted) residuals of a mono-exponential fit suitable 
    for use with the `gsl` [nonlinear least-squares solver](https://www.gnu.org/software/gsl/doc/html/nls.html#providing-the-function-to-be-minimized)

    \param[in] x pointer to a [`gsl_vector`](https://www.gnu.org/software/gsl/doc/html/vectors.html#vectors) 
    holding the present model parameter values
    \param[in] data pointer to a structure holding the "data" to fit
    \param[out] f pointer to a [`gsl_vector`](https://www.gnu.org/software/gsl/doc/html/vectors.html#vectors) 
    where the residuals get stored.
    \returns `GSL_SUCCESS` if everything goes fine
 */
int ratio_residuals (const gsl_vector * x,
		     void *data, 
		     gsl_vector * f)
{
  size_t i0 = ((ratio_for_fit *)data)-&gt;i0;
  size_t baseline_length = ((ratio_for_fit *)data)-&gt;baseline_length;
  ratio *pratio = ((ratio_for_fit *)data)-&gt;pratio;
  gsl_vector * time = pratio-&gt;TIME;
  gsl_vector * Ca = pratio-&gt;RATIO;
  gsl_vector * SE = pratio-&gt;RATIO_SE;
  size_t n = time-&gt;size;

  double baseline = gsl_vector_get (x, 0);
  double delta = gsl_vector_get (x, 1);
  double tau = gsl_vector_get (x, 2);

  size_t i;

  for (i=0; i&lt;baseline_length; i++)
    gsl_vector_set (f, i, (baseline - gsl_vector_get(Ca,i))/gsl_vector_get(SE,i));

  double t0 = gsl_vector_get(time,i0);
  for (size_t j=i0; j&lt;n; j++){
    /* Model Yj = delta * exp(-(tj-t0)/tau) + baseline */
    double dt = gsl_vector_get(time,j) - t0;
    double Yj = delta * exp (-dt/tau) + baseline;
    gsl_vector_set (f, i, (Yj - gsl_vector_get(Ca,j))/gsl_vector_get(SE,j));
    i++;
  }

  return GSL_SUCCESS;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org206fc73" class="outline-5">
<h5 id="org206fc73"><span class="section-number-5">3.3.1.12</span> <code>ratio_fit_callback</code></h5>
<div class="outline-text-5" id="text-3-3-1-12">
<p>
We define a function called after each iteration of the nonlinear least-squares solver that prints to the stderr information on the procedure.
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgf9a2034">/** \fn void ratio_fit_callback(const size_t iter, void *params,
    const gsl_multifit_nlinear_workspace *w)
    \brief A callback function printing progress during 
    [nonlinear least-squares fitting](https://www.gnu.org/software/gsl/doc/html/nls.html#high-level-driver)

    \param[in] iter the current iteration
    \param[in] params set to `NULL` when used but required by the [solver](https://www.gnu.org/software/gsl/doc/html/nls.html#high-level-driver)
    \param[in] w a pointer to the [`gsl_multifit_nlinear_workspace`](https://www.gnu.org/software/gsl/doc/html/nls.html#initializing-the-solver)
*/
void ratio_fit_callback(const size_t iter,
			void *params,
			const gsl_multifit_nlinear_workspace *w)
{
  gsl_vector *f = gsl_multifit_nlinear_residual(w);
  gsl_vector *x = gsl_multifit_nlinear_position(w);
  
  fprintf(stderr, "iter %2zu: baseline = %.4f, delta = %.4f, tau = %.4f, RSS = %.4f\n",
          iter,
          gsl_vector_get(x, 0),
          gsl_vector_get(x, 1),
          gsl_vector_get(x, 2),
          gsl_pow_2(gsl_blas_dnrm2(f)));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3317205" class="outline-5">
<h5 id="org3317205"><span class="section-number-5">3.3.1.13</span> <code>ratio_fit</code></h5>
<div class="outline-text-5" id="text-3-3-1-13">
<p>
Function <code>ratio_fit</code> fits a mono-exponential to the decaying part of a stimulation. Its skeleton is:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgad0ea50">/** \fn mono_exp_fit_res ratio_fit(ratio * pratio, size_t baseline,
    size_t start_fit, size_t maxit)
    \brief Fits a mono-exponential to the decaying part of a stimulation

    \param[in] pratio a pointer to a [ratio](@ref ratio) structure
    holding the "data"
    \param[in] baseline baseline length
    \param[in] start_fit the sampling point from which we start
    fitting the decay
    \param[in] the maximal number of iterations
    \returns a [mono_exp_fit_res](@ref mono_exp_fit_res) structure 
    holding the results
 */
mono_exp_fit_res ratio_fit(ratio * pratio,
			   size_t baseline,
			   size_t start_fit,
			   size_t maxit)
{
  // nobs: number of observations to fit
  const size_t nobs = baseline+pratio-&gt;TIME-&gt;size-start_fit;
  // p: number of model parameters
  const size_t p = 3;
  // data: a ratio_for_fit structure with the data and parameters
  //       required for computing the residuals
  ratio_for_fit data = {.i0=start_fit,
			.baseline_length=baseline,
			.pratio=pratio};

  &lt;&lt;ratio_fit_model_par&gt;&gt;

  &lt;&lt;ratio_fit_function_to_minimize_definition&gt;&gt;

  &lt;&lt;ratio_fit_solver_workspace_allocation_initialization&gt;&gt;
  
  &lt;&lt;ratio_fit_initial_rss_value&gt;&gt;

  &lt;&lt;ratio_fit_run_solver&gt;&gt;  
  
  &lt;&lt;ratio_fit_par_covar&gt;&gt;
  
  &lt;&lt;ratio_fit_final_rss_value&gt;&gt;

#define FIT(i) gsl_vector_get(w-&gt;x, i)
#define ERR(i) sqrt(gsl_matrix_get(covar,i,i))
  
  &lt;&lt;ratio_fit_print_end_info&gt;&gt;  

  // Prepare the output  
  mono_exp_fit_res res = {.nobs=nobs,
                          .baseline_length=baseline, 
			  .fit_start=start_fit,
			  .baseline=FIT(0),
			  .baseline_se=ERR(0),
			  .delta=FIT(1),
			  .delta_se=ERR(1),
			  .tau=FIT(2),
			  .tau_se=ERR(2),
			  .rss=rss,
			  .status=status};
  // Free allocated memory
  gsl_multifit_nlinear_free (w);
  gsl_matrix_free (covar);
  gsl_vector_free (par);

  return res;
}
</pre>
</div>

<p>
Code block <code>&lt;&lt;ratio_fit_model_par&gt;&gt;</code> allocates memory and initializes <code>par</code> a pointer to a <code>gsl</code> vector containing the 3 model parameters:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org2f21fc5">// par: contains the estimated model parameters baseline,
//      delta and tau
gsl_vector * par = gsl_vector_alloc(p);
// par initialization
gsl_vector_set(par,0, gsl_vector_get(pratio-&gt;RATIO,0));
gsl_vector_set(par,1, gsl_vector_get(pratio-&gt;RATIO,start_fit)-\
               gsl_vector_get(pratio-&gt;RATIO,0));
gsl_vector_set(par,2, gsl_vector_get(pratio-&gt;TIME,pratio-&gt;TIME-&gt;size-1)-\
	       gsl_vector_get(pratio-&gt;TIME,start_fit));
</pre>
</div>

<p>
Code block <code>&lt;&lt;ratio_fit_function_to_minimize_definition&gt;&gt;</code> initializes a <a href="https://www.gnu.org/software/gsl/manual/html_node/Nonlinear-Least_002dSquares-Function-Definition.html#Nonlinear-Least_002dSquares-Function-Definition">gsl_multifit_nlinear_fdf</a> structure containing the residuals function and accessory information required by the solver:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orga5d2f07">// define the function to be minimized
gsl_multifit_nlinear_fdf fdf = {.f = ratio_residuals,
				.df = NULL,  // set to NULL for finite-difference Jacobian
				.fvv = NULL, // not using geodesic acceleration 
				.n = nobs,
				.p = p,
				.params = &amp;data};
</pre>
</div>

<p>
Code block <code>&lt;&lt;ratio_fit_solver_workspace_allocation_initialization&gt;&gt;</code> allocates and initializes <code>w</code>, the <a href="https://www.gnu.org/software/gsl/manual/html_node/Nonlinear-Least_002dSquares-High-Level-Driver.html#Nonlinear-Least_002dSquares-High-Level-Driver">solver workspace</a> with default parameters:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org2344dc4">// allocate solver workspace with default parameters
  const gsl_multifit_nlinear_type *T = gsl_multifit_nlinear_trust;
gsl_multifit_nlinear_parameters fdf_params =
  gsl_multifit_nlinear_default_parameters();
gsl_multifit_nlinear_workspace *w = gsl_multifit_nlinear_alloc (T, &amp;fdf_params, nobs, p);

// initialize solver with starting point and weights
gsl_multifit_nlinear_init (par, &amp;fdf, w);
</pre>
</div>

<p>
Code block <code>&lt;&lt;ratio_fit_initial_rss_value&gt;&gt;</code> computes the initial value of the residual sum of squares (the criterion we want to minimize), the computed value is stored in variable <code>rss0</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org0eff355">// compute initial rss value
gsl_vector *residuals = gsl_multifit_nlinear_residual(w);
double rss0;
gsl_blas_ddot(residuals, residuals, &amp;rss0);
</pre>
</div>

<p>
Code block <code>&lt;&lt;ratio_fit_run_solver&gt;&gt;</code> does the main job of the function, it runs the solver for a maximal number of iterations (<code>maxit</code>) if the other stopping criteria are not met before. For the significance and values of <code>xtol</code>, <code>gtol</code> and <code>ftol</code> see the <a href="https://www.gnu.org/software/gsl/manual/html_node/Nonlinear-Least_002dSquares-Testing-for-Convergence.html#Nonlinear-Least_002dSquares-Testing-for-Convergence">gsl manual</a>.
</p>

<div class="org-src-container">
<pre class="src src-C" id="org7fe19ad">// solve the system with a maximum of maxit iterations
const double xtol = 1e-8;
const double gtol = 1e-8;
const double ftol = 0.0;
int info;
int status = gsl_multifit_nlinear_driver(maxit, xtol, gtol, ftol,
					 ratio_fit_callback, NULL,
					 &amp;info, w);
</pre>
</div>

<p>
Code block <code>&lt;&lt;ratio_fit_par_covar&gt;&gt;</code> computes the covariance matrix of the model parameters (stored in the <code>gsl_matrix</code> pointed to by <code>covar</code>) once the solver has returned.
</p>

<div class="org-src-container">
<pre class="src src-C" id="org211416a">gsl_matrix *J;
gsl_matrix *covar = gsl_matrix_alloc (p, p);
// compute covariance of best fit parameters
J = gsl_multifit_nlinear_jac(w);
gsl_multifit_nlinear_covar (J, 0.0, covar);
</pre>
</div>

<p>
Code block <code>&lt;&lt;ratio_fit_final_rss_value&gt;&gt;</code> computes the final RSS value and stores the result in variable <code>rss</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orga0a53d2">// compute final cost
double rss;
gsl_blas_ddot(residuals, residuals, &amp;rss);
</pre>
</div>

<p>
Code block <code>&lt;&lt;ratio_fit_print_end_info&gt;&gt;</code> prints details on the fitting procedure together with parameter estimations to the <code>stderr</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org1b408c1">// print end info
fprintf(stderr, "Fitted model Ca = baseline+delta*exp(-(t-t0)/tau)\n");
fprintf(stderr, "Summary from method '%s/%s'\n",
	gsl_multifit_nlinear_name(w),
	gsl_multifit_nlinear_trs_name(w));
fprintf(stderr, "number of iterations: %zu\n",
	gsl_multifit_nlinear_niter(w));
fprintf(stderr, "function evaluations: %zu\n", fdf.nevalf);
fprintf(stderr, "Jacobian evaluations: %zu\n", fdf.nevaldf);
fprintf(stderr, "reason for stopping: %s\n",
	(info == 1) ? "small step size" : "small gradient");
fprintf(stderr, "initial RSS = %f\n", rss0);
fprintf(stderr, "final   RSS = %f\n", rss);
fprintf(stderr, "\n");
fprintf(stderr,"Number of observation: %d\n", (int) nobs);
fprintf(stderr,"Number of degrees of freedom: %d\n", ((int) nobs)-3);
fprintf(stderr,"Baseline length: %d\n", (int) baseline);
fprintf(stderr,"Fit started from point %d\n", (int) start_fit);
fprintf(stderr,"Estimated baseline %g and standard error %g\n", FIT(0),ERR(0));
fprintf(stderr,"Estimated delta %g and standard error %g\n", FIT(1),ERR(1));
fprintf(stderr,"Estimated tau %g and standard error %g\n", FIT(2),ERR(2));
double dof = (((double) nobs)-3.0);
fprintf(stderr,"RSS per degree of freedom: %g\n", rss/dof);
double p_larger = gsl_cdf_chisq_Q(rss,dof);
fprintf(stderr,"Probability of observing a larger of equal RSS per DOF under the null hypothesis: %g\n",p_larger);
if (p_larger &lt; 0.01)
  fprintf(stderr,"WARNING: THE FIT IS NOT GOOD!\n");
fprintf(stderr,"\n");
</pre>
</div>
</div>
</div>

<div id="outline-container-org798c77a" class="outline-5">
<h5 id="org798c77a"><span class="section-number-5">3.3.1.14</span> <code>ratio_test</code></h5>
<div class="outline-text-5" id="text-3-3-1-14">
<div class="org-src-container">
<pre class="src src-C" id="org2b03ae5">/** \file ratio_test.c
    \brief Program testing the ratiometric functions
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;hdf5.h&gt;
#include &lt;hdf5_hl.h&gt;
#include &lt;gsl/gsl_math.h&gt;
#include &lt;gsl/gsl_vector.h&gt;
#include &lt;gsl/gsl_rng.h&gt;
#include &lt;gsl/gsl_randist.h&gt;
#include &lt;gsl/gsl_cdf.h&gt;
#include &lt;gsl/gsl_blas.h&gt;
#include &lt;gsl/gsl_multifit_nlinear.h&gt;
#include &lt;gsl/gsl_statistics_double.h&gt;
&lt;&lt;adu-type-definition&gt;&gt;
&lt;&lt;adu_alloc&gt;&gt;
&lt;&lt;adu_free&gt;&gt;
&lt;&lt;adu_get_set&gt;&gt;
&lt;&lt;adu_vector-type-definition&gt;&gt;
&lt;&lt;adu_vector_alloc&gt;&gt;
&lt;&lt;adu_vector_free&gt;&gt;
&lt;&lt;data_get_nelt&gt;&gt;
&lt;&lt;adu_vector_read_from_file&gt;&gt;
&lt;&lt;adu_printf&gt;&gt;
&lt;&lt;adu_vector_printf&gt;&gt;
&lt;&lt;dye-type-definition&gt;&gt;
&lt;&lt;dye_read_from_file&gt;&gt;
&lt;&lt;dye_printf&gt;&gt;
&lt;&lt;illumination-type-definition&gt;&gt;
&lt;&lt;illumination_read_from_file&gt;&gt;
&lt;&lt;illumination_printf&gt;&gt;
&lt;&lt;ccd-type-definition&gt;&gt;
&lt;&lt;ccd_read_from_file&gt;&gt;
&lt;&lt;ccd_printf&gt;&gt;
&lt;&lt;aba-type-definition&gt;&gt;
&lt;&lt;aba_alloc&gt;&gt;
&lt;&lt;aba_free&gt;&gt;
&lt;&lt;aba_read_from_file&gt;&gt;
&lt;&lt;aba_printf&gt;&gt;
&lt;&lt;ratio-type-definition&gt;&gt;
&lt;&lt;ratio_alloc&gt;&gt;
&lt;&lt;ratio_free&gt;&gt;
&lt;&lt;ratio_get_set&gt;&gt;
&lt;&lt;ratio_fprintf&gt;&gt;
&lt;&lt;ratio_est&gt;&gt;
&lt;&lt;ratio_find_fit_start&gt;&gt;
&lt;&lt;ratio_for_fit&gt;&gt;
&lt;&lt;ratio_residuals&gt;&gt;
&lt;&lt;ratio_fit_callback&gt;&gt;
&lt;&lt;mono_exp_fit_res&gt;&gt;
&lt;&lt;mono_exp_fit_res_fprintf&gt;&gt;
&lt;&lt;ratio_fit&gt;&gt;
#define FNAME "data_paper/data_beta_escin/DA_121219_E1.h5"
int main()
{
  // Open FILE
  char fname[] = FNAME;
  hid_t fid = H5Fopen (fname, H5F_ACC_RDONLY, H5P_DEFAULT);
  aba * paba = aba_read_from_file(fid);
  // Close file
  H5Fclose (fid);
  ratio * pratio = ratio_est(paba-&gt;data-&gt;adu_v[1],&amp;paba-&gt;dye,&amp;paba-&gt;light,&amp;paba-&gt;ccd,1000);
  aba_free(paba);
  ratio_fprintf(stdout,pratio);
  printf("\n\n");
  size_t start_pos = ratio_find_fit_start(pratio,0.5,15);
  mono_exp_fit_res res = ratio_fit(pratio,15,start_pos,25);
  mono_exp_fit_res_fprintf(stdout,&amp;res,pratio);
  ratio_free(pratio);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgabd61fb" class="outline-5">
<h5 id="orgabd61fb"><span class="section-number-5">3.3.1.15</span> <code>ratio_test</code> compilation and run</h5>
<div class="outline-text-5" id="text-3-3-1-15">
<p>
We compile the code with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org5122ce0">gcc -Wall -g -o code/ratio_test code/ratio_test.c -lgsl -lgslcblas -lhdf5 -lhdf5_hl -lm -std=gnu11
</pre>
</div>

<p>
We run it with valgrind:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org5e72a13">valgrind --leak-check=full ./code/ratio_test &gt; titi
</pre>
</div>

<pre class="example">
==15005== Memcheck, a memory error detector
==15005== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==15005== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info
==15005== Command: ./code/ratio_test
==15005== 
iter  0: baseline = 0.0586, delta = 0.1231, tau = 16.5000, RSS = 22664.2848
iter  1: baseline = 0.0597, delta = 0.0565, tau = 5.3161, RSS = 658.4080
iter  2: baseline = 0.0583, delta = 0.0629, tau = 3.8287, RSS = 414.3510
iter  3: baseline = 0.0585, delta = 0.0783, tau = 3.0541, RSS = 258.6214
iter  4: baseline = 0.0587, delta = 0.0971, tau = 2.5991, RSS = 155.1582
iter  5: baseline = 0.0588, delta = 0.1095, tau = 2.4067, RSS = 129.3976
iter  6: baseline = 0.0589, delta = 0.1132, tau = 2.3526, RSS = 127.7445
iter  7: baseline = 0.0589, delta = 0.1137, tau = 2.3436, RSS = 127.7223
iter  8: baseline = 0.0589, delta = 0.1137, tau = 2.3427, RSS = 127.7222
iter  9: baseline = 0.0589, delta = 0.1137, tau = 2.3427, RSS = 127.7222
iter 10: baseline = 0.0589, delta = 0.1137, tau = 2.3427, RSS = 127.7222
iter 11: baseline = 0.0589, delta = 0.1137, tau = 2.3427, RSS = 127.7222
iter 12: baseline = 0.0589, delta = 0.1137, tau = 2.3427, RSS = 127.7222
iter 13: baseline = 0.0589, delta = 0.1137, tau = 2.3427, RSS = 127.7222
Fitted model Ca = baseline+delta*exp(-(t-t0)/tau)
Summary from method 'trust-region/levenberg-marquardt'
number of iterations: 13
function evaluations: 72
Jacobian evaluations: 0
reason for stopping: small step size
initial RSS = 22664.284799
final   RSS = 127.722162

Number of observation: 181
Number of degrees of freedom: 178
Baseline length: 15
Fit started from point 34
Estimated baseline 0.0588818 and standard error 0.000546884
Estimated delta 0.113685 and standard error 0.00338681
Estimated tau 2.34267 and standard error 0.0946631
RSS per degree of freedom: 0.71754
Probability of observing a larger of equal RSS per DOF under the null hypothesis: 0.998311

==15005== 
==15005== HEAP SUMMARY:
==15005==     in use at exit: 0 bytes in 0 blocks
==15005==   total heap usage: 4,941 allocs, 4,941 frees, 2,441,573 bytes allocated
==15005== 
==15005== All heap blocks were freed -- no leaks are possible
==15005== 
==15005== For counts of detected and suppressed errors, rerun with: -v
==15005== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>

<p>
We can make a figure showing the ratiometric estimator, the standard error and the fit as follows:
</p>

<div class="org-src-container">
<pre class="src src-gnuplot" id="orgb4540ac">unset key
set grid
set multiplot title "" layout 2,1 margins 0.1,0.9,0.1,0.95 spacing 0,0
set ylabel "Normalized residuals"
set xtics format ""
plot 'titi' index 1 using 1:4 with lines linecolor rgb "red" linewidth 2
set format x "%g"
set xlabel "Time (s)"
set ylabel "Estimated [Ca2+]"
plot 'titi' index 0 using 1:2:($3*1.96) with yerrorlines \
     linecolor rgb "black" linewidth 1,\
     '' index 1 using 1:3 with lines linecolor rgb "red"\
     linewidth 2
unset multiplot
</pre>
</div>


<div class="figure">
<p><img src="figs/ratio_test_fig.png" alt="ratio_test_fig.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org158204f" class="outline-4">
<h4 id="org158204f"><span class="section-number-4">3.3.2</span> <code>ratio</code> header and source</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
The header part in code block <code>&lt;&lt;ratio.h&gt;&gt;</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org6dccd98">&lt;&lt;ratio-type-definition&gt;&gt;
ratio * ratio_alloc(size_t n_obs);
int ratio_free(ratio * ratio_ptr);
&lt;&lt;ratio_get_set&gt;&gt;
int ratio_fprintf(FILE * fp,ratio * pratio);
ratio * ratio_est(adu * padu, dye * pdye,illumination * plight,ccd * pccd,size_t nrep);
size_t ratio_find_fit_start(ratio * pratio, double remaining_fraction, size_t baseline);
&lt;&lt;mono_exp_fit_res&gt;&gt;
int mono_exp_fit_res_fprintf(FILE * fp, mono_exp_fit_res * str, ratio * pratio);
&lt;&lt;ratio_for_fit&gt;&gt;
int ratio_residuals (const gsl_vector * x, void *data, gsl_vector * f);
void ratio_fit_callback(const size_t iter, void *params, const gsl_multifit_nlinear_workspace *w);
mono_exp_fit_res ratio_fit(ratio * pratio, size_t baseline, size_t start_fit, size_t maxit);
</pre>
</div>

<p>
The function definitions <code>&lt;&lt;ratio.c&gt;&gt;</code> stored in file <code>code/ratio.c</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgeddebb7">/** \file ratio.c
    \brief Functions to work with the ratiometric estimator.
 */
#include "abaa.h"
&lt;&lt;ratio_alloc&gt;&gt;

&lt;&lt;ratio_free&gt;&gt;

&lt;&lt;ratio_fprintf&gt;&gt;

&lt;&lt;ratio_est&gt;&gt;

&lt;&lt;ratio_find_fit_start&gt;&gt;

&lt;&lt;ratio_residuals&gt;&gt;

&lt;&lt;ratio_fit_callback&gt;&gt;

&lt;&lt;mono_exp_fit_res_fprintf&gt;&gt;

&lt;&lt;ratio_fit&gt;&gt;
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org90c1bad" class="outline-2">
<h2 id="org90c1bad"><span class="section-number-2">4</span> Building the <code>abaa</code> library</h2>
<div class="outline-text-2" id="text-4">
<p>
We see that the part of <a href="#org2b03ae5">ratio_test</a> that precedes the <code>main</code> function is getting pretty large (to say the least)! This is a sign that it is time to define a library that we will call <code>abaa</code> for "Added Buffer Approach Analysis" that will contain all our functions, structures, etc.
</p>
</div>

<div id="outline-container-org7546e52" class="outline-3">
<h3 id="org7546e52"><span class="section-number-3">4.1</span> The <code>abaa.h</code> header file</h3>
<div class="outline-text-3" id="text-4-1">
<p>
File <code>abaa.h</code> will contain the structures, macros and function prototypes.
</p>

<div class="org-src-container">
<pre class="src src-C" id="org1162221">/** \file abaa.h
 *  \brief Header file for "added buffer approach analysis" 
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;getopt.h&gt;
#include &lt;math.h&gt;
#include &lt;hdf5.h&gt;
#include &lt;hdf5_hl.h&gt;
#include &lt;gsl/gsl_math.h&gt;
#include &lt;gsl/gsl_vector.h&gt;
#include &lt;gsl/gsl_rng.h&gt;
#include &lt;gsl/gsl_randist.h&gt;
#include &lt;gsl/gsl_cdf.h&gt;
#include &lt;gsl/gsl_blas.h&gt;
#include &lt;gsl/gsl_multifit_nlinear.h&gt;
#include &lt;gsl/gsl_statistics_double.h&gt;
#include &lt;gsl/gsl_fit.h&gt;
#include &lt;gsl/gsl_multifit.h&gt;
#include &lt;gsl/gsl_sort.h&gt;
#include &lt;gsl/gsl_sort_vector.h&gt;

&lt;&lt;adu.h&gt;&gt;

&lt;&lt;adu_vector.h&gt;&gt;

&lt;&lt;dye.h&gt;&gt;

&lt;&lt;illumination.h&gt;&gt;

&lt;&lt;ccd.h&gt;&gt;

&lt;&lt;aba.h&gt;&gt;

&lt;&lt;ratio.h&gt;&gt;

&lt;&lt;fura.h&gt;&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-orge542da2" class="outline-3">
<h3 id="orge542da2"><span class="section-number-3">4.2</span> The <code>Makefile</code></h3>
<div class="outline-text-3" id="text-4-2">
<div class="org-src-container">
<pre class="src src-makefile" id="org6350ec8">P=programe_name
OBJECTS=
CFLAGS += -g -Wall -std=gnu11 
LDLIBS = -lhdf5 -lhdf5_hl -lgsl -lgslcblas -lm 

$(P): $(OBJECTS)

all : libabaa.a adu_test adu_vector_test dye_test illumination_test \
ccd_test aba_test ratio_test ratio_test2

test : adu_test_run dye_test_run illumination_test_run ccd_test_run \
aba_test_run adu_vector_test_run ratio_test2_run

libabaa.a : adu.o adu_vector.o illumination.o dye.o ccd.o aba.o ratio.o \
fura.o
	ar cr libabaa.a adu.o adu_vector.o illumination.o dye.o ccd.o aba.o ratio.o \
fura.o

adu_test_objects=adu_test.o
adu_test : $(adu_test_objects)
	cc $(adu_test_objects) $(LDLIBS) -o adu_test

adu_test_run : adu_test
	./adu_test

adu_vector_test_objects=adu_vector_test.o
adu_vector_test : $(adu_vector_test_objects)
	cc $(adu_vector_test_objects) $(LDLIBS) -o adu_vector_test

adu_vector_test_run : adu_vector_test
	cd .. &amp;&amp; ./code/adu_vector_test &gt; toto &amp;&amp; gnuplot -persist code/adu_vector_test_plot_loading_curve.gp

dye_test_objects=dye_test.o
dye_test : $(dye_test_objects)
	cc $(dye_test_objects) $(LDLIBS) -o dye_test

dye_test_run : dye_test
	cd .. &amp;&amp; ./code/dye_test

illumination_test_objects=illumination_test.o
illumination_test : $(illumination_test_objects)
	cc $(illumination_test_objects) $(LDLIBS) -o illumination_test

illumination_test_run : illumination_test
	cd .. &amp;&amp; ./code/illumination_test

ccd_test_objects=ccd_test.o
ccd_test : $(ccd_test_objects)
	cc $(ccd_test_objects) $(LDLIBS) -o ccd_test

ccd_test_run : ccd_test
	cd .. &amp;&amp; ./code/ccd_test

aba_test_objects=aba_test.o
aba_test : $(aba_test_objects)
	cc $(aba_test_objects) $(LDLIBS) -o aba_test

aba_test_run : aba_test
	cd .. &amp;&amp; ./code/aba_test | head -n 30

ratio_test_objects=ratio_test.o
ratio_test : $(ratio_test_objects)
	cc $(ratio_test_objects) $(LDLIBS) -o ratio_test

ratio_test2.o : abaa.h

ratio_test2_objects=ratio_test2.o
ratio_test2 : $(ratio_test2_objects) libabaa.a
	cc $(ratio_test2_objects) libabaa.a $(LDLIBS) -o ratio_test2

ratio_test2_run : ratio_test2
	cd .. &amp;&amp; ./code/ratio_test2 &gt; titi &amp;&amp; gnuplot -persist code/ratio_test_fig.gp

fit_ratiometric : fit_ratiometric.o libabaa.a
	cc fit_ratiometric.o libabaa.a $(LDLIBS) -o fit_ratiometric

fura_concentration : fura_concentration.o libabaa.a
	cc fura_concentration.o libabaa.a $(LDLIBS) -o fura_concentration

fura_during_stim : fura_during_stim.o libabaa.a
	cc fura_during_stim.o libabaa.a $(LDLIBS) -o fura_during_stim

aba_ratio : aba_ratio.o libabaa.a
	cc aba_ratio.o libabaa.a $(LDLIBS) -o aba_ratio

.PHONY : clean
clean :
	rm -f libabaa.a adu.o adu_vector.o illumination.o dye.o ccd.o aba.o ratio.o \
	fura.o \
	$(adu_test_objects) adu_test \
	$(adu_vector_test_objects) adu_vector_test \
	$(dye_test_objects) dye_test \
	$(illumination_test_objects) illumination_test \
	$(ccd_test_objects) ccd_test \
	$(aba_test_objects) aba_test \
	$(ratio_test_objects) ratio_test \
	$(ratio_test2_objects) ratio_test2 \
	fit_ratiometric.o fit_ratiometric \
	fura_concentration.o fura_concentration \
	fura_during_stim.o fura_during_stim \
	aba_ratio.o aba_ratio
</pre>
</div>
</div>

<div id="outline-container-org0174599" class="outline-4">
<h4 id="org0174599"><span class="section-number-4">4.2.1</span> Testing that everything works</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
We redefine our last test function using the library:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orge196dfe">/** \file ratio_test2.c
    \brief Test program for the ratiometric estimator functions and
           structures of the abaa library.
 */
#include "abaa.h"
#define FNAME "data_paper/data_beta_escin/DA_121219_E1.h5"
int main()
{
  // Open FILE
  char fname[] = FNAME;
  hid_t fid = H5Fopen (fname, H5F_ACC_RDONLY, H5P_DEFAULT);
  aba * paba = aba_read_from_file(fid);
  // Close file
  H5Fclose (fid);
  ratio * pratio = ratio_est(paba-&gt;data-&gt;adu_v[3],&amp;paba-&gt;dye,&amp;paba-&gt;light,&amp;paba-&gt;ccd,1000);
  aba_free(paba);
  ratio_fprintf(stdout,pratio);
  printf("\n\n");
  size_t start_pos = ratio_find_fit_start(pratio,0.5,15);
  mono_exp_fit_res res = ratio_fit(pratio,15,start_pos,25);
  mono_exp_fit_res_fprintf(stdout,&amp;res,pratio);
  ratio_free(pratio);
  return 0;
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga9bdf37" class="outline-3">
<h3 id="orga9bdf37"><span class="section-number-3">4.3</span> The <code>SConstruct</code> file</h3>
<div class="outline-text-3" id="text-4-3">
<p>
As an alternative to <code>make</code>, we can use <a href="http://scons.org/">SCons</a> that requires <code>Python</code> and the definition of a <code>SConstruct</code> file that we now define (and write in the <code>code</code> folder):
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgb243b28">#!python
env = Environment()
env.Append(CCFLAGS = ['-g','-Wall','-std=gnu11'])
env.StaticLibrary(target="abaa",source=["adu.c","adu_vector.c","illumination.c","dye.c","ccd.c","aba.c","ratio.c"])

env.Program(target="adu_test",
            source="adu_test.c",
            LIBS=["hdf5","hdf5_hl","gsl","gslcblas","m"],LIBPATH=".")

env.Program(target="adu_vector_test",
            source="adu_vector_test.c",
            LIBS=["hdf5","hdf5_hl","gsl","gslcblas","m"],LIBPATH=".")

env.Program(target="dye_test",
            source="dye_test.c",
            LIBS=["hdf5","hdf5_hl","gsl","gslcblas","m"],LIBPATH=".")

env.Program(target="illumination_test",
            source="illumination_test.c",
            LIBS=["hdf5","hdf5_hl","gsl","gslcblas","m"],LIBPATH=".")

env.Program(target="ccd_test",
            source="ccd_test.c",
            LIBS=["hdf5","hdf5_hl","gsl","gslcblas","m"],LIBPATH=".")

env.Program(target="aba_test",
            source="aba_test.c",
            LIBS=["hdf5","hdf5_hl","gsl","gslcblas","m"],LIBPATH=".")

env.Program(target="ratio_test",
            source="ratio_test.c",
            LIBS=["hdf5","hdf5_hl","gsl","gslcblas","m"],LIBPATH=".")

env.Program(target="ratio_test2",
            source="ratio_test2.c",
            LIBS=["abaa","hdf5","hdf5_hl","gsl","gslcblas","m"],LIBPATH=".")

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd3e3b9e" class="outline-2">
<h2 id="orgd3e3b9e"><span class="section-number-2">5</span> Our first "user's" program: <code>fit_ratiometric</code></h2>
<div class="outline-text-2" id="text-5">
<p>
We now write, <code>fit_ratiometric</code>, our first user's program fitting a mono-exponential decay to the ratiometric estimator of a single transient.
</p>
</div>

<div id="outline-container-orgb022ce5" class="outline-3">
<h3 id="orgb022ce5"><span class="section-number-3">5.1</span> Program's task</h3>
<div class="outline-text-3" id="text-5-1">
<p>
<code>fit_ratiometric</code> is essentially a user friendly version of <a href="#org2b03ae5">ratio_test</a>. It will allow the user to specify:
</p>
<ul class="org-ul">
<li>an input file name containing the data.</li>
<li>an output file name prefix where results will get written.</li>
<li>a stimulation number (what stimulation does the user want to fit?).</li>
<li>a maximal number of iteration for the nonlinear least-squares solver.</li>
<li>a baseline length.</li>
<li>a location of a criteria to select from where the decay should be fitted.</li>
<li>a Boolean controlling the generation of a <code>gnuplot</code> script for quickly viewing the result.</li>
</ul>
</div>

<div id="outline-container-org10a85d6" class="outline-4">
<h4 id="org10a85d6"><span class="section-number-4">5.1.1</span> <code>fit_ratiometric</code> code</h4>
<div class="outline-text-4" id="text-5-1-1">
</div>
<div id="outline-container-orgd13b083" class="outline-5">
<h5 id="orgd13b083"><span class="section-number-5">5.1.1.1</span> <code>fit_ratiometric</code> skeleton</h5>
<div class="outline-text-5" id="text-5-1-1-1">
<div class="org-src-container">
<pre class="src src-C" id="org712f011">/** \file fit_ratiometric.c
    \brief Fits mono-exponential model to ratiometric estimator
 */
#include "abaa.h"
int main(int argc, char *argv[])
{
  &lt;&lt;fit_ratiometric-usage&gt;&gt;

  &lt;&lt;fit_ratiometric-args&gt;&gt;

  hid_t fid = H5Fopen (filename, H5F_ACC_RDONLY, H5P_DEFAULT);
  aba * paba = aba_read_from_file(fid);
  // Close file
  H5Fclose (fid);
  ratio * pratio = ratio_est(paba-&gt;data-&gt;adu_v[stim],&amp;paba-&gt;dye,&amp;paba-&gt;light,&amp;paba-&gt;ccd,1000);
  aba_free(paba);
  char out[512];
  strcpy(out,output);
  strcat(out,"_CaRatio");
  FILE *fp = fopen(out,"w");
  fprintf(fp,"# Data from %s stim %d\n",filename,(int) stim);
  fprintf(fp,"# Ratiometric estimator\n");
  ratio_fprintf(fp,pratio);
  fclose(fp);
  size_t start_pos;
  if (start_fit &gt;= 1)
    start_pos = (size_t) start_fit;
  else
    start_pos = ratio_find_fit_start(pratio,start_fit,baseline_length);
  mono_exp_fit_res res = ratio_fit(pratio,baseline_length,start_pos,maxiter);
  strcpy(out,output);
  strcat(out,"_RatioFit");
  fp = fopen(out,"w");
  fprintf(fp,"# Data from %s stim %d\n",filename,(int) stim);
  fprintf(fp,"# Ratiometric estimator mono-exponential fit\n");
  mono_exp_fit_res_fprintf(fp,&amp;res,pratio);
  fclose(fp);
  ratio_free(pratio);
  if (g_script) {
    &lt;&lt;fit_ratiometric_g_script&gt;&gt;
  }
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org79a8ca2" class="outline-5">
<h5 id="org79a8ca2"><span class="section-number-5">5.1.1.2</span> <code>&lt;&lt;fit_ratiometric-usage&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-5-1-1-2">
<div class="org-src-container">
<pre class="src src-C" id="orga8e64bc">static char usage[] = \
  "usage: %s -i --input=string -o --output=string [-s --stim=integer] ...\n"
  "          ... [-m --maxiter=integer] [-b --baseline_length=integer] ...\n"
  "          ... [-f --start_fit=real] [-g --graphic]\n\n"
  "  -i --input &lt;character string&gt;: data file name (e.g. data_paper/data_beta_escin/DA_121219_E1.h5)\n"
  "  -o --output &lt;character string&gt;: output file name prefix (e.g. 'DA_121219_E1_s1_ratio')\n"
  "  -s --stim &lt;positive integer&gt;: the stimulation to fit (default 1)\n"
  "  -m --max_iter &lt;positive integer&gt;: maximal number of iterations performed by\n"
  "       the nonlinear least-squares solver (default 50)\n"
  "  -b --baseline_length &lt;positive integer&gt;: baseline length in samples (default 15)\n"
  "  -f --start_fit &lt;positive real&gt;: where decay fit starts, if &gt; 1 interpreted as the\n"
  "       number of samples after the peak, if 0&lt;f&lt;1 interpreted as the remaining\n"
  "       fraction of the jump and fitting starts when the transient reaches that level\n"
  "  -g --graphics: if set, a gnuplot script file named output.gp is generated\n\n"
  " The program opens 'input' file, computes the ratiometric estimator from the raw data\n"
  " and fits the following model to it: Ca = baseline + delta * exp (-(t-t0)/tau)\n"
  " where t0 is the time on the decay phase at which the fit starts (set by parameter 'f').\n"
  " A constant is also fitted to the baseline region: Ca = baseline.\n"
  " Standard errors for the ratiometric estimator are obtained by Monte-Carlo simulation.\n"
  " While the program performs the least-squares optimization relevant information get printed\n"
  " to the stderr. The ratiometric estimator and its standard error are printed to a text\n"
  " file named 'output_CaRatio'. The fitted parameters, fitted values and residuals are\n"
  " printed to a text file named 'output_RatioFit'. If 'g' is selected, a gnuplot script\n"
  " file whose name is the 'output' name with the '.gp' suffix is generated. A graphical display\n"
  " of the result can then be obtained with: gnuplot -persist 'output.gp'\n\n";
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf805b91" class="outline-5">
<h5 id="orgf805b91"><span class="section-number-5">5.1.1.3</span> <code>&lt;&lt;fit_ratiometric-args&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-5-1-1-3">
<p>
This code block reads the program parameters. It assigns (after allocating memory if necessary):
</p>
<dl class="org-dl">
<dt>filename</dt><dd>pointer to a character string with the name of the data file.</dd>
<dt>output</dt><dd>pointer to a character string with the name of the output file name.</dd>
<dt>stim, maxiter, baseline_length</dt><dd>stim number, maximal number of iterations and baseline length.</dd>
<dt>start_fit</dt><dd>the number used to set from where the decay gets fitted.</dd>
<dt>g_script</dt><dd>indicates if a gnuplot script should be generated.</dd>
</dl>


<div class="org-src-container">
<pre class="src src-C" id="orgabf9119">char *filename;
char *output;
size_t stim=1, maxiter=50, baseline_length=15;
double start_fit=0.5;
int g_script=0;
{int opt;
  static struct option long_options[] = {
    {"input",required_argument,NULL,'i'},
    {"output",required_argument,NULL,'o'},
    {"stim",optional_argument,NULL,'s'},
    {"graphic",optional_argument,NULL,'g'},
    {"maxiter",optional_argument,NULL,'m'},
    {"baseline_length",optional_argument,NULL,'b'},
    {"start_fit",optional_argument,NULL,'f'},
    {"help",no_argument,NULL,'h'},
    {NULL,0,NULL,0}
  };
  int long_index =0;
  while ((opt = getopt_long(argc,argv,
                            "hgi:o:s:m:b:f:",
                            long_options,       
                            &amp;long_index)) != -1) {
    switch(opt) {
    case 'i':
    {
      filename = optarg;
    }
    break;
    case 'o':
    {
      output = optarg;
    }
    break;
    case 'g':
    {
      g_script=1;
    }
    break;
    case 's':
    {
      stim = (size_t) atoi(optarg);
    }
    break;
    case 'm':
    {
      maxiter = (size_t) atoi(optarg);
    }
    break;
    case 'b':
    {
      baseline_length = (size_t) atoi(optarg);
    }
    break;
    case 'f':
    {
      start_fit = (double) atof(optarg);
      if (start_fit&lt;=0) {
        fprintf(stderr,"start_fit should be &gt; 0.\n");
        return -1;
      }
    }
    break;
    case 'h': printf(usage,argv[0]);
      return -1;
    default : fprintf(stderr,usage,argv[0]);
      return -1;
    }
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org725a6fd" class="outline-5">
<h5 id="org725a6fd"><span class="section-number-5">5.1.1.4</span> <code>&lt;&lt;fit_ratiometric_g_script&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-5-1-1-4">
<p>
We write the <code>gnuplot</code> script generating the diagnostic plot:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgc169dba">strcpy(out,output);
strcat(out,".gp");
fp = fopen(out,"w");
char RatioFit[512];
strcpy(RatioFit,output);
strcat(RatioFit,"_RatioFit");
char CaRatio[512];
strcpy(CaRatio,output);
strcat(CaRatio,"_CaRatio");
char format[] = "%g";
fprintf(fp,
	"unset key\n"
	"set grid\n"
	"set multiplot title 'Data from %s stim %d' noenhanced layout 2,1 margins 0.1,0.9,0.1,0.95 spacing 0,0\n"
	"set ylabel 'Normalized residuals'\n"
	"set xtics format ''\n"
	"plot '%s' using 1:4 with lines linecolor rgb 'red' linewidth 2\n"
	"set format x '%s'\n"
	"set xlabel 'Time (s)'\n"
	"set ylabel 'Estimated [Ca2+]'\n"
	"plot '%s' using 1:2:($3*1.96) with yerrorlines	\\\n"
	"     linecolor rgb 'black' linewidth 1,		\\\n"
	"     '%s' using 1:3 with lines linecolor rgb 'red'\\\n"
	"     linewidth 2\n"
	"unset multiplot",
	filename, (int) stim, RatioFit, format, CaRatio, RatioFit);
fclose(fp);
</pre>
</div>
</div>
</div>

<div id="outline-container-org4a40650" class="outline-5">
<h5 id="org4a40650"><span class="section-number-5">5.1.1.5</span> <code>fit_ratiometric</code> compilation</h5>
<div class="outline-text-5" id="text-5-1-1-5">
<div class="org-src-container">
<pre class="src src-sh" id="orgfd9f211">cd code &amp;&amp; make fit_ratiometric
</pre>
</div>

<pre class="example">
cc -g -Wall -std=gnu11    -c -o fit_ratiometric.o fit_ratiometric.c
cc -g -Wall -std=gnu11    -c -o adu.o adu.c
cc -g -Wall -std=gnu11    -c -o adu_vector.o adu_vector.c
cc -g -Wall -std=gnu11    -c -o illumination.o illumination.c
cc -g -Wall -std=gnu11    -c -o dye.o dye.c
cc -g -Wall -std=gnu11    -c -o ccd.o ccd.c
cc -g -Wall -std=gnu11    -c -o aba.o aba.c
cc -g -Wall -std=gnu11    -c -o ratio.o ratio.c
cc -g -Wall -std=gnu11    -c -o fura.o fura.c
ar cr libabaa.a adu.o adu_vector.o illumination.o dye.o ccd.o aba.o ratio.o \
fura.o
cc fit_ratiometric.o libabaa.a -lhdf5 -lhdf5_hl -lgsl -lgslcblas -lm  -o fit_ratiometric
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org18f26a5" class="outline-3">
<h3 id="org18f26a5"><span class="section-number-3">5.2</span> Using <code>fit_ratiometric</code></h3>
<div class="outline-text-3" id="text-5-2">
<p>
What to do if we forget how to use the program?
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org97f9b43">./code/fit_ratiometric --help
</pre>
</div>

<pre class="example">
usage: ./code/fit_ratiometric -i --input=string -o --output=string [-s --stim=integer] ...
          ... [-m --maxiter=integer] [-b --baseline_length=integer] ...
          ... [-f --start_fit=real] [-g --graphic]

  -i --input &lt;character string&gt;: data file name (e.g. data_paper/data_beta_escin/DA_121219_E1.h5)
  -o --output &lt;character string&gt;: output file name prefix (e.g. 'DA_121219_E1_s1_ratio')
  -s --stim &lt;positive integer&gt;: the stimulation to fit (default 1)
  -m --max_iter &lt;positive integer&gt;: maximal number of iterations performed by
       the nonlinear least-squares solver (default 50)
  -b --baseline_length &lt;positive integer&gt;: baseline length in samples (default 15)
  -f --start_fit &lt;positive real&gt;: where decay fit starts, if &gt; 1 interpreted as the
       number of samples after the peak, if 0&lt;f&lt;1 interpreted as the remaining
       fraction of the jump and fitting starts when the transient reaches that level
  -g --graphics: if set, a gnuplot script file named output.gp is generated

 The program opens 'input' file, computes the ratiometric estimator from the raw data
 and fits the following model to it: Ca = baseline + delta * exp (-(t-t0)/tau)
 where t0 is the time on the decay phase at which the fit starts (set by parameter 'f').
 A constant is also fitted to the baseline region: Ca = baseline.
 Standard errors for the ratiometric estimator are obtained by Monte-Carlo simulation.
 While the program performs the least-squares optimization relevant information get printed
 to the stderr. The ratiometric estimator and its standard error are printed to a text
 file named 'output_CaRatio'. The fitted parameters, fitted values and residuals are
 printed to a text file named 'output_RatioFit'. If 'g' is selected, a gnuplot script
 file whose name is the 'output' name with the '.gp' suffix is generated. A graphical display
 of the result can then be obtained with: gnuplot -persist 'output.gp'

</pre>

<p>
Fine so lets fit the second stimulation of our test dataset:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org6504121">./code/fit_ratiometric -i data_paper/data_beta_escin/DA_121219_E1.h5 -o DA_121219_E1_s2 -s 2 -g
</pre>
</div>

<pre class="example">
iter  0: baseline = 0.0505, delta = 0.0755, tau = 15.7000, RSS = 17219.2218
iter  1: baseline = 0.0532, delta = 0.0525, tau = 1.2056, RSS = 3257.7394
iter  2: baseline = 0.0563, delta = 0.0633, tau = 3.3014, RSS = 402.2209
iter  3: baseline = 0.0530, delta = 0.0794, tau = 3.0219, RSS = 172.8142
iter  4: baseline = 0.0530, delta = 0.0797, tau = 3.0698, RSS = 171.1807
iter  5: baseline = 0.0530, delta = 0.0797, tau = 3.0718, RSS = 171.1802
iter  6: baseline = 0.0530, delta = 0.0797, tau = 3.0718, RSS = 171.1802
iter  7: baseline = 0.0530, delta = 0.0797, tau = 3.0719, RSS = 171.1802
iter  8: baseline = 0.0530, delta = 0.0797, tau = 3.0719, RSS = 171.1802
iter  9: baseline = 0.0530, delta = 0.0797, tau = 3.0719, RSS = 171.1802
Fitted model Ca = baseline+delta*exp(-(t-t0)/tau)
Summary from method 'trust-region/levenberg-marquardt'
number of iterations: 9
function evaluations: 46
Jacobian evaluations: 0
reason for stopping: small step size
initial RSS = 17219.221778
final   RSS = 171.180170

Number of observation: 173
Number of degrees of freedom: 170
Baseline length: 15
Fit started from point 42
Estimated baseline 0.0530184 and standard error 0.000378172
Estimated delta 0.0796949 and standard error 0.00142419
Estimated tau 3.07185 and standard error 0.0901479
RSS per degree of freedom: 1.00694
Probability of observing a larger of equal RSS per DOF under the null hypothesis: 0.460172

</pre>


<p>
We can use valgrind to make sure everything is fine:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org609df78">valgrind ./code/fit_ratiometric -i data_paper/data_beta_escin/DA_121219_E1.h5 -o DA_121219_E1_s2 -s 2 -g
</pre>
</div>



<p>
We can look at the top part of file <code>DA_121219_E1_s2_RatioFit</code> with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org17044e0">head DA_121219_E1_s2_RatioFit -n 25
</pre>
</div>

<pre class="example">
# Data from data_paper/data_beta_escin/DA_121219_E1.h5 stim 2
# Ratiometric estimator mono-exponential fit
# Fitted model Ca = baseline+delta*exp(-(t-t0)/tau)
# nobs = 173
# number of degrees of freedom = 170
# baseline length = 15
# fit started from point 42
# estimated baseline 0.0530184 and standard error 0.000378172
# estimated delta 0.0796949 and standard error 0.00142419
# estimated tau 3.07185 and standard error 0.0901479
# residual sum of squares: 171.18
# RSS per degree of freedom: 1.00694
# Probability of observing a larger of equal RSS per DOF under the null hypothesis: 0.460172

# rss per degree of freedom: 1.00694

# Time    Ca  Prediction  Residual
2830.01 0.0504706 0.0530184 -0.913407
2830.11 0.0531824 0.0530184 0.0593775
2830.21 0.0454172 0.0530184 -2.90247
2830.31 0.0466744 0.0530184 -2.42539
2830.41 0.054658 0.0530184 0.581709
2830.51 0.0583309 0.0530184 1.88669
2830.61 0.053892 0.0530184 0.304269
2830.71 0.0554407 0.0530184 0.80927
</pre>




<p>
We get the diagnostic plot with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org128a28a">gnuplot -persist DA_121219_E1_s2.gp
</pre>
</div>


<div class="figure">
<p><img src="figs/DA_121219_E1_s2-plot.png" alt="DA_121219_E1_s2-plot.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org80c75d5" class="outline-2">
<h2 id="org80c75d5"><span class="section-number-2">6</span> Getting Fura concentration during a stimulation: <code>fura_concentration</code></h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-org56afe51" class="outline-3">
<h3 id="org56afe51"><span class="section-number-3">6.1</span> Motivation</h3>
<div class="outline-text-3" id="text-6-1">
<p>
To implement the added buffer approach we need to know (or estimate) the Fura concentration within the cell during a transient. To that end, we write a new program, <code>fura_concentration</code>, that prints to the <code>stdout</code> the estimated [Fura].
</p>
</div>
<div id="outline-container-org938dd87" class="outline-4">
<h4 id="org938dd87"><span class="section-number-4">6.1.1</span> <code>fura_concentration</code> code</h4>
<div class="outline-text-4" id="text-6-1-1">
</div>
<div id="outline-container-orgb44d3d8" class="outline-5">
<h5 id="orgb44d3d8"><span class="section-number-5">6.1.1.1</span> <code>fura_concentration</code> skeleton</h5>
<div class="outline-text-5" id="text-6-1-1-1">
<div class="org-src-container">
<pre class="src src-C" id="orgd14d8bc">/** \file fura_concentration.c
    \brief Program computing the [Fura] and returning it to the stdout
 */
#include "abaa.h"
int main(int argc, char *argv[])
{
  &lt;&lt;fura_concentration-usage&gt;&gt;

  &lt;&lt;fura_concentration-args&gt;&gt;

  hid_t fid = H5Fopen (filename, H5F_ACC_RDONLY, H5P_DEFAULT);
  aba * paba = aba_read_from_file(fid);
  // Close file
  H5Fclose (fid);
  ts_vector *pfura = fura_est(paba);
  aba_free(paba);
  ts_vector_fprintf(stdout,pfura);
  ts_vector_free(pfura);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb2ac7a5" class="outline-5">
<h5 id="orgb2ac7a5"><span class="section-number-5">6.1.1.2</span> <code>&lt;&lt;fura_concentration-usage&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-6-1-1-2">
<div class="org-src-container">
<pre class="src src-C" id="org3f880fb">static char usage[] = \
  "usage: %s -i --input=string\n"
  "  -i --input &lt;character string&gt;: data file name (e.g. data_paper/data_beta_escin/DA_121219_E1.h5)\n\n"
  " The program opens 'input' file, estimates the [Fura] within the cell\n"
  " and prints it to the 'stdout'. The loading curve measurements appear first\n"
  " followed by the individual stimalation separated by two blank lines.\n"
  " Results are printed on two columns: Time and [Fura].\n\n"
  " IT IS ASSUMED THAT WHEN THE MAXIMAL BACKGROUND SUBTRACTED FLUORESCENCE AT\n"
  " 360 nm IS OBSERVED, THE FURA CONCENTRATION IN THE CELL AND IN THE PIPETTE\n"
  " ARE IDENTICAL (NO EXTRAPOLATION BASED ON A FIT IS PERFORMED).\n\n";
</pre>
</div>
</div>
</div>

<div id="outline-container-org1c0bf6a" class="outline-5">
<h5 id="org1c0bf6a"><span class="section-number-5">6.1.1.3</span> <a id="org1e6b7fe"></a></h5>
<div class="outline-text-5" id="text-6-1-1-3">
<p>
This code block reads the program parameters. It assigns (after allocating memory if necessary):
</p>
<dl class="org-dl">
<dt>filename</dt><dd>pointer to a character string with the name of the data file.</dd>
</dl>

<div class="org-src-container">
<pre class="src src-C" id="orgc1fe091">char *filename;
{int opt;
  static struct option long_options[] = {
    {"input",required_argument,NULL,'i'},
    {"help",no_argument,NULL,'h'},
    {NULL,0,NULL,0}
  };
  int long_index =0;
  while ((opt = getopt_long(argc,argv,
                            "hi:s:f:",
                            long_options,       
                            &amp;long_index)) != -1) {
    switch(opt) {
    case 'i':
    {
      filename = optarg;
    }
    break;
    case 'h': printf(usage,argv[0]);
      return -1;
    default : fprintf(stderr,usage,argv[0]);
      return -1;
    }
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org42749f0" class="outline-5">
<h5 id="org42749f0"><span class="section-number-5">6.1.1.4</span> <code>fura_concentration</code> compilation</h5>
<div class="outline-text-5" id="text-6-1-1-4">
<div class="org-src-container">
<pre class="src src-sh" id="orgdae5888">cd code &amp;&amp; make fura_concentration
</pre>
</div>

<pre class="example">
cc -g -Wall -std=gnu11    -c -o fura_concentration.o fura_concentration.c
cc fura_concentration.o libabaa.a -lhdf5 -lhdf5_hl -lgsl -lgslcblas -lm  -o fura_concentration
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org30bd292" class="outline-3">
<h3 id="org30bd292"><span class="section-number-3">6.2</span> Using <code>fura_concentration</code></h3>
<div class="outline-text-3" id="text-6-2">
<p>
What to do if we forget how to use the program?
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org096b168">./code/fura_concentration --help
</pre>
</div>

<pre class="example">
usage: ./code/fura_concentration -i --input=string
  -i --input &lt;character string&gt;: data file name (e.g. data_paper/data_beta_escin/DA_121219_E1.h5)

 The program opens 'input' file, estimates the [Fura] within the cell
 and prints it to the 'stdout'. The loading curve measurements appear first
 followed by the individual stimalation separated by two blank lines.
 Results are printed on two columns: Time and [Fura].

 IT IS ASSUMED THAT WHEN THE MAXIMAL BACKGROUND SUBTRACTED FLUORESCENCE AT
 360 nm IS OBSERVED, THE FURA CONCENTRATION IN THE CELL AND IN THE PIPETTE
 ARE IDENTICAL (NO EXTRAPOLATION BASED ON A FIT IS PERFORMED).

</pre>


<p>
We run it (at "valgrind" it at the same time) with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org0c42805">valgrind ./code/fura_concentration -i data_paper/data_beta_escin/DA_121219_E1.h5 &gt; DA_121219_E1_fura 
</pre>
</div>

<pre class="example">
==15056== Memcheck, a memory error detector
==15056== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==15056== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info
==15056== Command: ./code/fura_concentration -i data_paper/data_beta_escin/DA_121219_E1.h5
==15056== 
==15056== 
==15056== HEAP SUMMARY:
==15056==     in use at exit: 0 bytes in 0 blocks
==15056==   total heap usage: 4,864 allocs, 4,864 frees, 2,414,493 bytes allocated
==15056== 
==15056== All heap blocks were freed -- no leaks are possible
==15056== 
==15056== For counts of detected and suppressed errors, rerun with: -v
==15056== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>


<p>
Displaying the output is straightforward with <code>gnuplot</code>:
</p>


<div class="figure">
<p><img src="figs/DA_121219_E1_fura-plot.png" alt="DA_121219_E1_fura-plot.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgbe7e138" class="outline-3">
<h3 id="orgbe7e138"><span class="section-number-3">6.3</span> <code>fura_during_stim</code></h3>
<div class="outline-text-3" id="text-6-3">
<p>
We now define a program that reads from the <code>stdin</code> fura concentrations having the same format as what <code>fura_concentration</code> prints to the <code>stdout</code> and then get the mean, min and max [Fura] values during a specific part of a stimulation.
</p>
</div>


<div id="outline-container-orgf865a5e" class="outline-4">
<h4 id="orgf865a5e"><span class="section-number-4">6.3.1</span> <code>fura_during_stim</code> code</h4>
<div class="outline-text-4" id="text-6-3-1">
</div>
<div id="outline-container-org7dd6921" class="outline-5">
<h5 id="org7dd6921"><span class="section-number-5">6.3.1.1</span> <code>fura_during_stim</code> skeleton</h5>
<div class="outline-text-5" id="text-6-3-1-1">
<div class="org-src-container">
<pre class="src src-C" id="org45f3891">/** \file fura_during_stim.c
    \brief Use output of fura_concentration to get mean, min and max [Fura]
           during a specific stimulation.
 */
#include "abaa.h"
int main(int argc, char *argv[])
{
  &lt;&lt;fura_during_stim-usage&gt;&gt;

  &lt;&lt;fura_during_stim-args&gt;&gt;

  char buffer[256];
  int n1,n2;
  int in=0;
  // Read line per line
  while (fgets(buffer, sizeof(buffer), stdin) &amp;&amp; in == 0)
    // Look for right pattern in line
    if (2 == sscanf(buffer, "# Stim %d with %d elements", &amp;n1,&amp;n2))
      // Extract relevant value
      if ((size_t) n1 == stim)
	in = 1;
  if (in==0)
    printf("Stim %d not found!\n", (int) stim);
  size_t n_obs = n2;
  // Advance start_fit-1 lines
  size_t i;
  for (i=0; i&lt;start_fit; i++)
    fgets(buffer, sizeof(buffer), stdin);
  double fura_cum=0.0,fura_min=1e6,fura_max=0.0;
  for (; i&lt;n_obs; i++) {
    float time,fura_val;
    double fura;
    fscanf(stdin,"%f %f",&amp;time,&amp;fura_val);
    fura = (double) fura_val;
    fura_cum += fura;
    if (fura &lt; fura_min)
      fura_min = fura;
    if (fura &gt; fura_max)
      fura_max=fura;
  }
  printf("%g %g %g\n",
	 fura_cum/(n_obs-start_fit),
	 fura_min,
	 fura_max);
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org09bd5ab" class="outline-5">
<h5 id="org09bd5ab"><span class="section-number-5">6.3.1.2</span> <code>&lt;&lt;fura_during_stim-usage&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-6-3-1-2">
<div class="org-src-container">
<pre class="src src-C" id="orgab55b81">static char usage[] = \
  "usage: %s [-s --stim=integer] -f --start_fit=integer \n\n"
  "  -s --stim &lt;positive integer&gt;: the stimulation to fit (default 1)\n"
  "  -f --start_fit &lt;positive integer&gt;: sample point where decay fit starts\n\n"
  " The program reads [Fura] from the 'stdin', data are assumed organized in 3 columns:\n"
  "   Index Time and [Fura]\n"
  " Several data sets called 'loading curve', 'Stimulation 1', 'Stimulation 2', etc\n"
  " are assumed to be present with 2 blank lines (gnuplot style) separating each data\n"
  " set. Each set starts with its name following a '#', the next line also starts with a\n"
  " '#' and contains '# xxx observations', where 'xxx' is the number of observations in\n"
  " the data set. The program goes to stimulation specified by 's' (default 1) and starts\n"
  " dealing with data starting from observation specified by parameter 'f'. The value of\n"
  " the latter parameter should be set to the value given in line '# fit started from point yy'\n"
  " in the file generated by a call to 'fit_ratiometric' ('yy' stands for the value of 'f').\n"
  " The program prints to the 'stdout' the mean, min and max [Fura] from point 'f'.\n\n";
</pre>
</div>
</div>
</div>

<div id="outline-container-org548ac8b" class="outline-5">
<h5 id="org548ac8b"><span class="section-number-5">6.3.1.3</span> <code>&lt;&lt;fura_during_stim-args&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-6-3-1-3">
<p>
This code block reads the program parameters. It assigns:
</p>
<dl class="org-dl">
<dt>stim</dt><dd>stim number.</dd>
<dt>start_fit</dt><dd>the sample point from which the decay gets fitted.</dd>
</dl>

<div class="org-src-container">
<pre class="src src-C" id="orga776f4f">size_t stim=1;
size_t start_fit;
{int opt;
  static struct option long_options[] = {
    {"stim",optional_argument,NULL,'s'},
    {"start_fit",required_argument,NULL,'f'},
    {"help",no_argument,NULL,'h'},
    {NULL,0,NULL,0}
  };
  int long_index =0;
  while ((opt = getopt_long(argc,argv,
                            "hs:f:",
                            long_options,       
                            &amp;long_index)) != -1) {
    switch(opt) {
    case 's':
    {
      stim = (size_t) atoi(optarg);
    }
    break;
    case 'f':
    {
      start_fit = (size_t) atof(optarg);
    }
    break;
    case 'h': printf(usage,argv[0]);
      return -1;
    default : fprintf(stderr,usage,argv[0]);
      return -1;
    }
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga7cb63d" class="outline-5">
<h5 id="orga7cb63d"><span class="section-number-5">6.3.1.4</span> <code>fura_during_stim</code> compilation</h5>
<div class="outline-text-5" id="text-6-3-1-4">
<div class="org-src-container">
<pre class="src src-sh" id="org22498ca">cd code &amp;&amp; make fura_during_stim
</pre>
</div>

<pre class="example">
cc -g -Wall -std=gnu11    -c -o fura_during_stim.o fura_during_stim.c
cc fura_during_stim.o libabaa.a -lhdf5 -lhdf5_hl -lgsl -lgslcblas -lm  -o fura_during_stim
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1049f33" class="outline-3">
<h3 id="org1049f33"><span class="section-number-3">6.4</span> Using <code>fura_during_stim</code></h3>
<div class="outline-text-3" id="text-6-4">
<p>
What to do if we forget how to use the program?
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orga636c3f">./code/fura_during_stim --help
</pre>
</div>

<pre class="example">
usage: ./code/fura_during_stim [-s --stim=integer] -f --start_fit=integer 

  -s --stim &lt;positive integer&gt;: the stimulation to fit (default 1)
  -f --start_fit &lt;positive integer&gt;: sample point where decay fit starts

 The program reads [Fura] from the 'stdin', data are assumed organized in 3 columns:
   Index Time and [Fura]
 Several data sets called 'loading curve', 'Stimulation 1', 'Stimulation 2', etc
 are assumed to be present with 2 blank lines (gnuplot style) separating each data
 set. Each set starts with its name following a '#', the next line also starts with a
 '#' and contains '# xxx observations', where 'xxx' is the number of observations in
 the data set. The program goes to stimulation specified by 's' (default 1) and starts
 dealing with data starting from observation specified by parameter 'f'. The value of
 the latter parameter should be set to the value given in line '# fit started from point yy'
 in the file generated by a call to 'fit_ratiometric' ('yy' stands for the value of 'f').
 The program prints to the 'stdout' the mean, min and max [Fura] from point 'f'.

</pre>


<p>
We run it with (we do not need a valgrind test here since the program doesn't perform any memory allocation):
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgf19afca">./code/fura_during_stim -s 2 -f 42 &lt; DA_121219_E1_fura 
</pre>
</div>

<pre class="example">
64.3812 61.4134 67.0886
</pre>



<p>
We can do the last call in a more sophisticated and more automatic manner:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orge3beb1a">file_name=DA_121219_E1_s2_RatioFit
stim=`grep "stim " $file_name | sed -e "s/# Data .* stim //g"`
start_fit=`grep "# fit started from point" $file_name | sed -e "s/# fit started from point //g"`
./code/fura_concentration -i data_paper/data_beta_escin/DA_121219_E1.h5 | ./code/fura_during_stim -s $stim -f $start_fit 
</pre>
</div>

<pre class="example">
64.3812 61.4134 67.0886
</pre>



<p>
We can now construct a line containing everything we will need for the weighted linear regression leading to the endogenous \(\kappa\) parameter in the added buffer approach with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org1ebcc2d">file_name=DA_121219_E1_s2_RatioFit
stim=`grep "stim " $file_name | sed -e "s/# Data .* stim //g"`
start_fit=`grep "# fit started from point" $file_name | sed -e "s/# fit started from point //g"`
fura_conc=`./code/fura_concentration -i data_paper/data_beta_escin/DA_121219_E1.h5 | ./code/fura_during_stim -s $stim -f $start_fit` 
tau_and_se=`grep "# estimated tau" $file_name | sed -e "s/# estimated tau //g" | sed -e "s/ and standard error//g"`
Ca=`grep "# estimated baseline" $file_name | sed -e "s/# estimated baseline //g" | sed -e "s/ and standard error .*//g"`
echo $fura_conc $Ca $tau_and_se
</pre>
</div>

<pre class="example">
64.3812 61.4134 67.0886 0.0530184 3.07185 0.0901479
</pre>
</div>
</div>
</div>


<div id="outline-container-org13cbbda" class="outline-2">
<h2 id="org13cbbda"><span class="section-number-2">7</span> Getting the time constant as a function of \(\kappa_{F}\)</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org8d510af" class="outline-3">
<h3 id="org8d510af"><span class="section-number-3">7.1</span> We start by fitting each of the free transients of data set <code>DA_121219_E1.h5</code></h3>
<div class="outline-text-3" id="text-7-1">
</div>
<div id="outline-container-org8f71222" class="outline-4">
<h4 id="org8f71222"><span class="section-number-4">7.1.1</span> First transient</h4>
<div class="outline-text-4" id="text-7-1-1">
<div class="org-src-container">
<pre class="src src-sh" id="orgd6bca82">./code/fit_ratiometric -i data_paper/data_beta_escin/DA_121219_E1.h5 -o DA_121219_E1_s1 -s 1 -g
</pre>
</div>

<pre class="example">
iter  0: baseline = 0.0586, delta = 0.1231, tau = 16.5000, RSS = 22664.2848
iter  1: baseline = 0.0597, delta = 0.0565, tau = 5.3161, RSS = 658.4080
iter  2: baseline = 0.0583, delta = 0.0629, tau = 3.8287, RSS = 414.3510
iter  3: baseline = 0.0585, delta = 0.0783, tau = 3.0541, RSS = 258.6214
iter  4: baseline = 0.0587, delta = 0.0971, tau = 2.5991, RSS = 155.1582
iter  5: baseline = 0.0588, delta = 0.1095, tau = 2.4067, RSS = 129.3976
iter  6: baseline = 0.0589, delta = 0.1132, tau = 2.3526, RSS = 127.7445
iter  7: baseline = 0.0589, delta = 0.1137, tau = 2.3436, RSS = 127.7223
iter  8: baseline = 0.0589, delta = 0.1137, tau = 2.3427, RSS = 127.7222
iter  9: baseline = 0.0589, delta = 0.1137, tau = 2.3427, RSS = 127.7222
iter 10: baseline = 0.0589, delta = 0.1137, tau = 2.3427, RSS = 127.7222
iter 11: baseline = 0.0589, delta = 0.1137, tau = 2.3427, RSS = 127.7222
iter 12: baseline = 0.0589, delta = 0.1137, tau = 2.3427, RSS = 127.7222
Fitted model Ca = baseline+delta*exp(-(t-t0)/tau)
Summary from method 'trust-region/levenberg-marquardt'
number of iterations: 12
function evaluations: 56
Jacobian evaluations: 0
reason for stopping: small step size
initial RSS = 22664.284799
final   RSS = 127.722162

Number of observation: 181
Number of degrees of freedom: 178
Baseline length: 15
Fit started from point 34
Estimated baseline 0.0588818 and standard error 0.000546884
Estimated delta 0.113685 and standard error 0.00338681
Estimated tau 2.34267 and standard error 0.0946631
RSS per degree of freedom: 0.71754
Probability of observing a larger of equal RSS per DOF under the null hypothesis: 0.998311

</pre>


<p>
We then get the first line of our tau versus Fura file:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org5deec50">./code/fura_concentration -i data_paper/data_beta_escin/DA_121219_E1.h5 &gt; DA_121219_E1_fura 
file_name=DA_121219_E1_s1_RatioFit
stim=`grep "stim " $file_name | sed -e "s/# Data .* stim //g"`
start_fit=`grep "# fit started from point" $file_name | sed -e "s/# fit started from point //g"`
fura_conc=`./code/fura_during_stim -s $stim -f $start_fit &lt; DA_121219_E1_fura` 
tau_and_se=`grep "# estimated tau" $file_name | sed -e "s/# estimated tau //g" | sed -e "s/ and standard error//g"`
Ca=`grep "# estimated baseline" $file_name | sed -e "s/# estimated baseline //g" | sed -e "s/ and standard error .*//g"`
echo $fura_conc $Ca $tau_and_se &gt; DA_121219_E1_tau_vs_fura
</pre>
</div>
</div>
</div>


<div id="outline-container-orgb27c43f" class="outline-4">
<h4 id="orgb27c43f"><span class="section-number-4">7.1.2</span> Second transient</h4>
<div class="outline-text-4" id="text-7-1-2">
<div class="org-src-container">
<pre class="src src-sh" id="org8f7b8da">./code/fit_ratiometric -i data_paper/data_beta_escin/DA_121219_E1.h5 -o DA_121219_E1_s2 -s 2 -g
</pre>
</div>

<pre class="example">
iter  0: baseline = 0.0505, delta = 0.0755, tau = 15.7000, RSS = 17219.2218
iter  1: baseline = 0.0532, delta = 0.0525, tau = 1.2056, RSS = 3257.7394
iter  2: baseline = 0.0563, delta = 0.0633, tau = 3.3014, RSS = 402.2209
iter  3: baseline = 0.0530, delta = 0.0794, tau = 3.0219, RSS = 172.8142
iter  4: baseline = 0.0530, delta = 0.0797, tau = 3.0698, RSS = 171.1807
iter  5: baseline = 0.0530, delta = 0.0797, tau = 3.0718, RSS = 171.1802
iter  6: baseline = 0.0530, delta = 0.0797, tau = 3.0718, RSS = 171.1802
iter  7: baseline = 0.0530, delta = 0.0797, tau = 3.0719, RSS = 171.1802
iter  8: baseline = 0.0530, delta = 0.0797, tau = 3.0719, RSS = 171.1802
iter  9: baseline = 0.0530, delta = 0.0797, tau = 3.0719, RSS = 171.1802
Fitted model Ca = baseline+delta*exp(-(t-t0)/tau)
Summary from method 'trust-region/levenberg-marquardt'
number of iterations: 9
function evaluations: 46
Jacobian evaluations: 0
reason for stopping: small step size
initial RSS = 17219.221778
final   RSS = 171.180170

Number of observation: 173
Number of degrees of freedom: 170
Baseline length: 15
Fit started from point 42
Estimated baseline 0.0530184 and standard error 0.000378172
Estimated delta 0.0796949 and standard error 0.00142419
Estimated tau 3.07185 and standard error 0.0901479
RSS per degree of freedom: 1.00694
Probability of observing a larger of equal RSS per DOF under the null hypothesis: 0.460172

</pre>


<p>
We then get the second line of our tau versus Fura file:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org4ad5d43">file_name=DA_121219_E1_s2_RatioFit
stim=`grep "stim " $file_name | sed -e "s/# Data .* stim //g"`
start_fit=`grep "# fit started from point" $file_name | sed -e "s/# fit started from point //g"`
fura_conc=`./code/fura_during_stim -s $stim -f $start_fit &lt; DA_121219_E1_fura` 
tau_and_se=`grep "# estimated tau" $file_name | sed -e "s/# estimated tau //g" | sed -e "s/ and standard error//g"`
Ca=`grep "# estimated baseline" $file_name | sed -e "s/# estimated baseline //g" | sed -e "s/ and standard error .*//g"`
echo $fura_conc $Ca $tau_and_se &gt;&gt; DA_121219_E1_tau_vs_fura
</pre>
</div>
</div>
</div>

<div id="outline-container-org89ed8cb" class="outline-4">
<h4 id="org89ed8cb"><span class="section-number-4">7.1.3</span> Third transient</h4>
<div class="outline-text-4" id="text-7-1-3">
<div class="org-src-container">
<pre class="src src-sh" id="org58a5a09">./code/fit_ratiometric -i data_paper/data_beta_escin/DA_121219_E1.h5 -o DA_121219_E1_s3 -s 3 -g
</pre>
</div>

<pre class="example">
iter  0: baseline = 0.0507, delta = 0.0530, tau = 14.7000, RSS = 10888.6212
iter  1: baseline = 0.0494, delta = 0.0467, tau = 1.1453, RSS = 5829.0426
iter  2: baseline = 0.0559, delta = 0.0383, tau = 3.1382, RSS = 963.6889
iter  3: baseline = 0.0508, delta = 0.0549, tau = 4.5807, RSS = 204.7654
iter  4: baseline = 0.0499, delta = 0.0560, tau = 4.3772, RSS = 158.6090
iter  5: baseline = 0.0500, delta = 0.0561, tau = 4.3649, RSS = 158.5868
iter  6: baseline = 0.0500, delta = 0.0561, tau = 4.3638, RSS = 158.5868
iter  7: baseline = 0.0500, delta = 0.0561, tau = 4.3637, RSS = 158.5868
iter  8: baseline = 0.0500, delta = 0.0561, tau = 4.3637, RSS = 158.5868
iter  9: baseline = 0.0500, delta = 0.0561, tau = 4.3637, RSS = 158.5868
iter 10: baseline = 0.0500, delta = 0.0561, tau = 4.3637, RSS = 158.5868
iter 11: baseline = 0.0500, delta = 0.0561, tau = 4.3637, RSS = 158.5868
Fitted model Ca = baseline+delta*exp(-(t-t0)/tau)
Summary from method 'trust-region/levenberg-marquardt'
number of iterations: 11
function evaluations: 48
Jacobian evaluations: 0
reason for stopping: small step size
initial RSS = 10888.621234
final   RSS = 158.586760

Number of observation: 163
Number of degrees of freedom: 160
Baseline length: 15
Fit started from point 52
Estimated baseline 0.049958 and standard error 0.000388658
Estimated delta 0.05609 and standard error 0.000821936
Estimated tau 4.36367 and standard error 0.13015
RSS per degree of freedom: 0.991167
Probability of observing a larger of equal RSS per DOF under the null hypothesis: 0.516723

</pre>


<p>
We then get the third line of our tau versus Fura file:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org124aa36">file_name=DA_121219_E1_s3_RatioFit
stim=`grep "stim " $file_name | sed -e "s/# Data .* stim //g"`
start_fit=`grep "# fit started from point" $file_name | sed -e "s/# fit started from point //g"`
fura_conc=`./code/fura_during_stim -s $stim -f $start_fit &lt; DA_121219_E1_fura` 
tau_and_se=`grep "# estimated tau" $file_name | sed -e "s/# estimated tau //g" | sed -e "s/ and standard error//g"`
Ca=`grep "# estimated baseline" $file_name | sed -e "s/# estimated baseline //g" | sed -e "s/ and standard error .*//g"`
echo $fura_conc $Ca $tau_and_se &gt;&gt; DA_121219_E1_tau_vs_fura
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfc7b5b6" class="outline-3">
<h3 id="orgfc7b5b6"><span class="section-number-3">7.2</span> Plotting \(\tau\) as a function of \(\kappa_F\)</h3>
<div class="outline-text-3" id="text-7-2">
<p>
We plot the results with <code>gnuplot</code>:
</p>


<div class="figure">
<p><img src="figs/DA_121219_E1_tau_vs_fura-plot.png" alt="DA_121219_E1_tau_vs_fura-plot.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org74a6e6b" class="outline-2">
<h2 id="org74a6e6b"><span class="section-number-2">8</span> A program doing all that at once</h2>
<div class="outline-text-2" id="text-8">
<p>
It can become quit "painful" to repeat the steps of the previous section all other for each new experiment. We therefore write a program that does everything at once:
</p>
<ol class="org-ol">
<li>Reads the data.</li>
<li>Get the loading curve.</li>
<li>Fits a mono-exponential decay to the ratiometric estimators of the user specified stimulations.</li>
<li>Fits a weighted linear regression to the decay time constant vs \(\kappa_{F}\) and get the two key parameters: \(\gamma/v\) and \(\kappa_{S}\).</li>
</ol>
<p>
A text file (or several ones, like in step 3) is/are generated at each step.
</p>
</div>

<div id="outline-container-orgfeaa307" class="outline-3">
<h3 id="orgfeaa307"><span class="section-number-3">8.1</span> The <code>aba_ratio</code> program</h3>
<div class="outline-text-3" id="text-8-1">
<p>
We will call our <code>aba_ratio</code> since it implements the added buffer approach using the ratiometric estimator.
</p>
</div>

<div id="outline-container-orgf4e19e1" class="outline-4">
<h4 id="orgf4e19e1"><span class="section-number-4">8.1.1</span> <code>aba_ratio</code> code</h4>
<div class="outline-text-4" id="text-8-1-1">
</div>
<div id="outline-container-org1b3a380" class="outline-5">
<h5 id="org1b3a380"><span class="section-number-5">8.1.1.1</span> <code>aba_ratio</code> skeleton</h5>
<div class="outline-text-5" id="text-8-1-1-1">
<p>
The program  <code>&lt;&lt;aba_ratio.c&gt;&gt;</code> gets stored in file <code>code/aba_ratio.c</code>:
</p>

<div class="org-src-container">
<pre class="src src-C" id="orgf56747b">/** \file aba_ratio.c
    \brief Added buffer approach using the ratiometric estimator

    This program does "everything at once":
    1. Reads the data.
    2. Get the loading curve.
    3. Fits a mono-exponential decay to the ratiometric estimators of the user specified stimulations.
    4. Fits a weighted linear regression to the decay time constant vs \f$\kappa_{F}\f$ and get the two key parameters: \f$\gamma/v\f$ and \f$\kappa_{S}\f$.
    
    The last fit, time constant vs \f$\kappa_{F}\f$, is performed in 3 different ways using respectively the mean \f$\kappa_{F}\f$
    value during the fitted part of the transient, the minimal or the maximal value. 
    A text file (or several ones, like in step 3) is/are generated at each step.
 */
#include "abaa.h"

/** \def NREP 10000
    \brief Number of replicates in MC/Bootstrap simulations
 */
#define NREP 10000



int wls_fit(const gsl_vector * kappa,
	    mono_exp_fit_res * fit_res,
	    size_t n_stim,
	    char * filename,
	    char * output,
	    gsl_rng * rng,
	    int what,
	    size_t *stim);

int robust_fit(const gsl_vector * kappa,
	       mono_exp_fit_res * fit_res,
	       size_t n_stim,
	       char * filename,
	       char * output,
	       gsl_rng * rng,
	       int what,
	       size_t *stim);

int main(int argc, char *argv[])
{
  /*
    This code block defines a character strings containing the
    help of the program.
   */
  &lt;&lt;aba_ratio-usage&gt;&gt;

  /*
     This code block reads the program parameters. It assigns (after allocating memory if necessary):
     - filename: pointer to a character string with the name of the data file.
     - output: pointer to a character string with the name of the output file name.
     - stim: an array with the numbers of the stimulations to use.
     - maxiter, baseline_length: maximal number of iterations and baseline length.
     - start_fit: the number used to set from where the decay gets fitted.
     - g_script: indicates if a gnuplot script should be generated.
    */  
  &lt;&lt;aba_ratio-args&gt;&gt;

  /*
     This code block opens HDF5 file `filename`. 
     `paba` is a pointer to an aba structure that gets
     allocated and initialized.
     Do not forget to free the memory pointed to by `paba` before
     program exit. 
  */
  &lt;&lt;aba_ratio-read-data&gt;&gt;

  /*
     This code block allocates and initializes a ts_vector
     structure pointed to by `pfura`.
     A char array, `out`, with 512 elements is declared.
     A file pointer, `fp`, is declared.
     The loading curve is printed to a file named `output_loading_curve`.
     Do not forget to free `pfura` before program exit.
  */
  &lt;&lt;aba_ratio-get-loading-curve&gt;&gt;

  if (g_script) {
    /*
      This code block generated a gnuplot script
      making the loading curve figure.
      A char array, `file4gp`, with 512 elements is declared.
     */
    &lt;&lt;aba_ratio_loading_curve_g_script&gt;&gt;
  }

  /*
  The next code blocks get the ratiometric estimator
  and to the mono-exponential fit for each selected
  stimulation. 
  */
  mono_exp_fit_res fit_res[n_stim];
  for (size_t s_idx=0; s_idx&lt;n_stim; s_idx++) {
    &lt;&lt;aba_ratio_ratiometric_estimator&gt;&gt;
    &lt;&lt;aba_ratio_mono_exp_fit&gt;&gt;
    if (g_script) {
      &lt;&lt;aba_ratio_mono_exp_g_script&gt;&gt;
    }
  }

  /*
  The next block gets the mean, min and max kappa_Fura 
  values at each stimulation. The result is stored
  in three gsl_vector called kappa_mu, kappa_inf and kappa_sup.
  These vectors must be freed before exiting the program.
  */
  &lt;&lt;aba_ratio_kappa_Fura&gt;&gt;
  
  /*
  The next code block does 3 linear regressions
  of tau on mean / min / max kappa_Fura
  */
  &lt;&lt;aba_ratio_tau_vs_kappa&gt;&gt;

  
  if (g_script) {
    &lt;&lt;aba_ratio_tau_vs_kappa_g_script&gt;&gt;
  }

  gsl_vector_free(kappa_mu);
  gsl_vector_free(kappa_inf);
  gsl_vector_free(kappa_sup);
  aba_free(paba);
  ts_vector_free(pfura);
  free(stim); 
  return 0;
}

#define BETA0(c) gsl_vector_get((c),0)

#define BETA0_SE(cov) sqrt(gsl_matrix_get((cov),0,0))

#define BETA0_VAR(cov) gsl_matrix_get((cov),0,0)

#define BETA1(c) gsl_vector_get((c),1)

#define BETA1_SE(cov) sqrt(gsl_matrix_get((cov),1,1))

#define BETA1_VAR(cov) gsl_matrix_get((cov),1,1)

#define gamma_over_v_hat(c) 1.0/BETA1((c))

#define gamma_over_v_se(c,cov) BETA1_SE((cov))/	\
  gsl_pow_2(BETA1((c)))

#define kappa_s(c) BETA0((c))/BETA1((c))-1.0

#define kappa_s_se(c,cov) sqrt(BETA0_VAR((cov))/gsl_pow_2(BETA1((c)))+\
			       BETA1_VAR((cov))*gsl_pow_2(BETA0((c)))/gsl_pow_4(BETA1((c))))

&lt;&lt;wls_fit&gt;&gt;

&lt;&lt;robust_fit&gt;&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org3047dcf" class="outline-5">
<h5 id="org3047dcf"><span class="section-number-5">8.1.1.2</span> <code>&lt;&lt;aba_ratio-usage&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-8-1-1-2">
<div class="org-src-container">
<pre class="src src-C" id="org78935d1">static char usage[] = \
  "usage: %s -i --input=string [-o --output=string] ...\n"
  "          ... [-s --stim=integer,integer,integer] ...\n"
  "          ... [-m --maxiter=integer] [-b --baseline_length=integer] ...\n"
  "          ... [-f --start_fit=real] [-r --robust] [-g --graphic]\n\n"
  "  -i --input &lt;character string&gt;: data file name (e.g. data_paper/data_beta_escin/DA_121219_E1.h5)\n"
  "  -o --output &lt;character string&gt;: output file name prefix (e.g. 'DA_121219_E1_s1_ratio');\n"
  "       if not specificied, the '.h5' is stripped from 'input' and '_aba' is added\n"
  "  -s --stim &lt;positive integer&gt;: coma separated list of stimulations to fit\n"
  "       (default all stimulation considered).\n"
  "  -m --max_iter &lt;positive integer&gt;: maximal number of iterations performed by\n"
  "       the nonlinear least-squares solver (default 50).\n"
  "  -b --baseline_length &lt;positive integer&gt;: baseline length in samples (default 15).\n"
  "  -f --start_fit &lt;positive real&gt;: where decay fit starts, if &gt; 1 interpreted as the\n"
  "       number of samples after the peak, if 0&lt;f&lt;1 interpreted as the remaining\n"
  "       fraction of the jump and fitting starts when the transient reaches that level.\n"
  "       Default value: 0.5.\n"
  "  -r --robust: if set, a robust linear regression of tau vs kappa_Fura is performed\n"
  "       using a bi-square weight function.\n"
  "  -g --graphics: if set, gnuplot script files are generated.\n\n"
  " The program opens 'input' file, get the loading curve and prints the result to a file\n"
  " named output_loading_curve; then for every stimulation specified in the 'stim' list \n"
  " it computes the ratiometric estimator from the raw data\n"
  " and fits the following model to it: Ca = baseline + delta * exp (-(t-t0)/tau)\n"
  " where t0 is the time on the decay phase at which the fit starts (set by parameter 'f').\n"
  " A constant is also fitted to the baseline region: Ca = baseline.\n"
  " Standard errors for the ratiometric estimator are obtained by Monte-Carlo simulation.\n"
  " While the program performs the least-squares optimization relevant information get printed\n"
  " to the stderr. The ratiometric estimator and its standard error are printed to a text\n"
  " file named 'output_CaRatio_sX' (where 'X' stands for the stimulation number. The fitted\n"
  " parameters, fitted values and residuals are printed to a text file named 'output_RatioFit_sX'.\n"
  " If 'g' is selected, a gnuplot script file whose name is the 'output_YY_sX.gp' where 'YY' is\n"
  " either 'loading_curve' or 'RatioFit' 'is generated. A graphical display\n"
  " of the result can then be obtained with: gnuplot -persist 'output_YY_sX.gp'\n\n"
  " Once each specified stimulation has been fitted, a regression of tau vs kappa is performed\n"
  " using three different values for kappa: the mean value during the fitted part of the transient,\n"
  " the minimal and the maximal values. Information and fit results get printed to the 'stderr' as\n"
  " well as to files named 'output_aba_tau_vs_mean/min/max_kappa', if option '-g' is set, gnuplot\n"
  " script files are also generated with names 'output_aba_tau_vs_mean/min/max_kappa.gp'\n\n"
  " When a robust linear regression is requested (by using optional argument '-r' or '--robust'\n"
  " when calling the program), a bi-square weight function is used (see:\n"
  " https://www.gnu.org/software/gsl/doc/html/lls.html#robust-linear-regression). Since\n"
  " the robust methods implemented in the GSL do not allow for the use of the standard errors on\n"
  " the dependent variable, we multiply the observations in order to have approximately the\n"
  " right standard error ratio: that is, if an observation has a standard error of 0.13 and\n"
  " another one has 0.091, we will include two identical copies of the second since (0.13/0.091)^2\n"
  " is approximately 2. This use of multiple copies is reported to the user.\n\n";
</pre>
</div>
</div>
</div>

<div id="outline-container-org1eb82fe" class="outline-5">
<h5 id="org1eb82fe"><span class="section-number-5">8.1.1.3</span> <code>&lt;&lt;aba_ratio-args&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-8-1-1-3">
<div class="org-src-container">
<pre class="src src-C" id="orgc749c4b">char *filename;
char output[512];
size_t maxiter=50, baseline_length=15;
double start_fit=0.5;
int g_script=0;
size_t n_stim = 0; // initialize the stimulation counter
size_t *stim;
int do_robust = 0; 
int out_unset=1; // Indicator of output specification  
{int opt;
  static struct option long_options[] = {
    {"input",required_argument,NULL,'i'},
    {"output",optional_argument,NULL,'o'},
    {"stim",optional_argument,NULL,'s'},
    {"graphic",optional_argument,NULL,'g'},
    {"maxiter",optional_argument,NULL,'m'},
    {"baseline_length",optional_argument,NULL,'b'},
    {"start_fit",optional_argument,NULL,'f'},
    {"robust",optional_argument,NULL,'r'},
    {"help",no_argument,NULL,'h'},
    {NULL,0,NULL,0}
  };
  int long_index =0;
  while ((opt = getopt_long(argc,argv,
                            "hgri:o:s:m:b:f:",
                            long_options,       
                            &amp;long_index)) != -1) {
    switch(opt) {
    case 'i':
    {
      filename = optarg;
    }
    break;
    case 'o':
    {
      out_unset = 0;
      strcpy(output,optarg);
    }
    break;
    case 'g':
    {
      g_script=1;
    }
    break;
    case 'r':
    {
      do_robust=1;
    }
    break;
    case 's':
    {
      char *start = strdup(optarg); // duplicate optarg content
      char *running;
      running = start;
      char *token  = strsep(&amp;running, ",");
      while (token != NULL) {
	token = strsep (&amp;running, ","); // split optarg at each ","
	n_stim++;
      }
      free(start);
      // The number of stimulation is now known
      // Allocate memory for the vector of stim indexes
      stim=malloc(n_stim*sizeof(size_t));
      start = strdup(optarg); // duplicate optarg content again
      running = start;
      // Get the index of each stimulation
      for (size_t i=0; i&lt;n_stim; i++) {
	token = strsep (&amp;running, ",");
	stim[i] = (size_t) atoi(token);
      }
      free(start);
    }
    break;
    case 'm':
    {
      maxiter = (size_t) atoi(optarg);
    }
    break;
    case 'b':
    {
      baseline_length = (size_t) atoi(optarg);
    }
    break;
    case 'f':
    {
      start_fit = (double) atof(optarg);
      if (start_fit&lt;=0) {
        fprintf(stderr,"start_fit should be &gt; 0.\n");
        return -1;
      }
    }
    break;
    case 'h': printf(usage,argv[0]);
      return -1;
    default : fprintf(stderr,usage,argv[0]);
      return -1;
    }
  }
}
// Set output prefix name if not given
if (out_unset) {
  char *start = strdup(filename); // duplicate filename content
  char *p = strtok(start,"."); // stop at ".h5"
  strcpy(output,p);
  strcat(output,"_aba");
  free(start);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdcca341" class="outline-5">
<h5 id="orgdcca341"><span class="section-number-5">8.1.1.4</span> <code>&lt;&lt;aba_ratio-read-data&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-8-1-1-4">
<div class="org-src-container">
<pre class="src src-C" id="orgb4720f8">hid_t fid = H5Fopen (filename, H5F_ACC_RDONLY, H5P_DEFAULT);
aba * paba = aba_read_from_file(fid);
// Close file
H5Fclose (fid);
// Take care of the default for stim
if (n_stim == 0) {
  n_stim = paba-&gt;data-&gt;nelt-1;
  stim = malloc(n_stim*sizeof(size_t));
  for (size_t s_idx=0; s_idx&lt;n_stim; s_idx++)
    stim[s_idx]=s_idx+1;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgce4031c" class="outline-5">
<h5 id="orgce4031c"><span class="section-number-5">8.1.1.5</span> <code>&lt;&lt;aba_ratio-get-loading-curve&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-8-1-1-5">
<div class="org-src-container">
<pre class="src src-C" id="org128ad43">ts_vector *pfura = fura_est(paba);
char out[512];
strcpy(out,output);
strcat(out,"_loading_curve");
FILE *fp = fopen(out,"w");
fprintf(fp,"# Cellular [Fura] for dataset %s\n\n",filename);
ts_vector_fprintf(fp,pfura);
fclose(fp);
</pre>
</div>
</div>
</div>

<div id="outline-container-org3b6e375" class="outline-5">
<h5 id="org3b6e375"><span class="section-number-5">8.1.1.6</span> <code>&lt;&lt;aba_ratio_loading_curve_g_script&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-8-1-1-6">
<p>
We write the <code>gnuplot</code> script generating the diagnostic plot:
</p>

<div class="org-src-container">
<pre class="src src-C" id="org9bbbb7e">char file4gp[512];
strcpy(file4gp,output);
strcat(file4gp,"_loading_curve");
strcpy(out,output);
strcat(out,"_loading_curve.gp");
fp = fopen(out,"w");
fprintf(fp,
	"unset key\n"
	"set grid\n"
	"set ylabel '[Fura] (µM)'\n"
	"set xlabel 'Time (s)'\n"
	"plot '%s' index 0 using 1:2 linecolor rgb 'black',\\\n",
	file4gp);
for (size_t i=0; i&lt;n_stim; i++)
  fprintf(fp,
	  "'' index %d using 1:2 with lines linecolor rgb 'red',\\\n",
	  (int) i+1);
fclose(fp);
</pre>
</div>
</div>
</div>

<div id="outline-container-org2d9cd87" class="outline-5">
<h5 id="org2d9cd87"><span class="section-number-5">8.1.1.7</span> <code>&lt;&lt;aba_ratio_ratiometric_estimator&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-8-1-1-7">
<div class="org-src-container">
<pre class="src src-C" id="orgf87f656">fprintf(stderr,
	"**********************************\n"
	"* Doing now stimulation %d\n"
	"**********************************\n",
	(int) stim[s_idx]);
ratio * pratio = ratio_est(paba-&gt;data-&gt;adu_v[stim[s_idx]],
			   &amp;paba-&gt;dye,&amp;paba-&gt;light,
			   &amp;paba-&gt;ccd,NREP);
strcpy(out,output);
strcat(out,"_CaRatio_s");
char stim_nb[99];
sprintf(stim_nb,"%d", (int) stim[s_idx]);
strcat(out,stim_nb);
FILE *fp = fopen(out,"w");
fprintf(fp,"# Data from %s stim %d\n",filename,(int) stim[s_idx]);
fprintf(fp,"# Ratiometric estimator\n");
ratio_fprintf(fp,pratio);
fclose(fp);
</pre>
</div>
</div>
</div>

<div id="outline-container-org014763c" class="outline-5">
<h5 id="org014763c"><span class="section-number-5">8.1.1.8</span> <code>&lt;&lt;aba_ratio_mono_exp_fit&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-8-1-1-8">
<div class="org-src-container">
<pre class="src src-C" id="org50f68e0">size_t start_pos;
if (start_fit &gt;= 1)
  start_pos = (size_t) start_fit;
else
  start_pos = ratio_find_fit_start(pratio,start_fit,baseline_length);
fit_res[s_idx] = ratio_fit(pratio,baseline_length,start_pos,maxiter);
strcpy(out,output);
strcat(out,"_RatioFit_s");
strcat(out,stim_nb);
fp = fopen(out,"w");
fprintf(fp,"# Data from %s stim %d\n",filename,(int) stim[s_idx]);
fprintf(fp,"# Ratiometric estimator mono-exponential fit\n");
mono_exp_fit_res_fprintf(fp,&amp;fit_res[s_idx],pratio);
fclose(fp);
ratio_free(pratio);
fprintf(stderr,
	"**********************************\n"
	"* Stimulation %d done\n"
	"**********************************\n\n",
	(int) stim[s_idx]);
</pre>
</div>
</div>
</div>

<div id="outline-container-org2994563" class="outline-5">
<h5 id="org2994563"><span class="section-number-5">8.1.1.9</span> <code>&lt;&lt;aba_ratio_mono_exp_g_script&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-8-1-1-9">
<div class="org-src-container">
<pre class="src src-C" id="org14ba472">strcpy(out,output);
strcat(out,"_RatioFit_s");
strcat(out,stim_nb);
strcat(out,".gp");
fp = fopen(out,"w");
char RatioFit[512];
strcpy(RatioFit,output);
strcat(RatioFit,"_RatioFit_s");
strcat(RatioFit,stim_nb);
char CaRatio[512];
strcpy(CaRatio,output);
strcat(CaRatio,"_CaRatio_s");
strcat(CaRatio,stim_nb);
char format[] = "%g";
fprintf(fp,
        "unset key\n"
        "set grid\n"
        "set multiplot title 'Data from %s stim %d' noenhanced layout 2,1 margins 0.1,0.9,0.1,0.95 spacing 0,0\n"
        "set ylabel 'Normalized residuals'\n"
        "set xtics format ''\n"
        "plot '%s' using 1:4 with lines linecolor rgb 'red' linewidth 2\n"
        "set format x '%s'\n"
        "set xlabel 'Time (s)'\n"
        "set ylabel 'Estimated [Ca2+]'\n"
        "plot '%s' using 1:2:($3*1.96) with yerrorlines \\\n"
        "     linecolor rgb 'black' linewidth 1,                \\\n"
        "     '%s' using 1:3 with lines linecolor rgb 'red'\\\n"
        "     linewidth 2\n"
        "unset multiplot",
        filename, (int) stim[s_idx], RatioFit, format, CaRatio, RatioFit);
fclose(fp);
</pre>
</div>
</div>
</div>

<div id="outline-container-org7320514" class="outline-5">
<h5 id="org7320514"><span class="section-number-5">8.1.1.10</span> <code>&lt;&lt;aba_ratio_kappa_Fura&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-8-1-1-10">
<div class="org-src-container">
<pre class="src src-C" id="orgb4f41ea">gsl_vector * kappa_mu = gsl_vector_alloc(n_stim);
gsl_vector * kappa_inf = gsl_vector_alloc(n_stim);
gsl_vector * kappa_sup = gsl_vector_alloc(n_stim);
for (size_t s_idx=0; s_idx&lt;n_stim; s_idx++) {
  double K_d=paba-&gt;dye.K_d_hat;
  double Ca = (fit_res[s_idx]).baseline;
  double res=K_d/gsl_pow_2(K_d+Ca);
  double res_inf,res_sup;
  gsl_vector * fura_conc=pfura-&gt;ts_v[stim[s_idx]]-&gt;AMPLITUDE;
  gsl_vector_const_view Fura=gsl_vector_const_subvector(fura_conc,
							(fit_res[s_idx]).fit_start,
							fura_conc-&gt;size-(fit_res[s_idx]).fit_start);
  // We take as [Fura] the mean [Fura] over the fitted decay period
  res *= gsl_stats_mean(Fura.vector.data,1,Fura.vector.size);
  gsl_stats_minmax(&amp;res_inf,&amp;res_sup,Fura.vector.data,1,Fura.vector.size);
  gsl_vector_set(kappa_mu, s_idx, res);
  gsl_vector_set(kappa_inf, s_idx, res_inf*K_d/gsl_pow_2(K_d+Ca));
  gsl_vector_set(kappa_sup, s_idx, res_sup*K_d/gsl_pow_2(K_d+Ca));
}				
</pre>
</div>
</div>
</div>

<div id="outline-container-org92706dc" class="outline-5">
<h5 id="org92706dc"><span class="section-number-5">8.1.1.11</span> <code>&lt;&lt;aba_ratio_tau_vs_kappa&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-8-1-1-11">
<div class="org-src-container">
<pre class="src src-C" id="org812b7d5">// Set up RNG for MC
const gsl_rng_type * T = gsl_rng_default;
gsl_rng_env_setup();
gsl_rng * rng = gsl_rng_alloc (T);

if (do_robust) {
  // Fit and print tau vs mean kappa value
  robust_fit(kappa_mu,fit_res,n_stim,filename,output,rng,0,stim);

  // Fit and print tau vs min kappa value
  robust_fit(kappa_inf,fit_res,n_stim,filename,output,rng,1,stim);

  // Fit and print tau vs max kappa value
  robust_fit(kappa_sup,fit_res,n_stim,filename,output,rng,2,stim);
} else {
  // Fit and print tau vs mean kappa value
  wls_fit(kappa_mu,fit_res,n_stim,filename,output,rng,0,stim);

  // Fit and print tau vs min kappa value
  wls_fit(kappa_inf,fit_res,n_stim,filename,output,rng,1,stim);

  // Fit and print tau vs max kappa value
  wls_fit(kappa_sup,fit_res,n_stim,filename,output,rng,2,stim);  
}
// Free RNG
gsl_rng_free (rng);

</pre>
</div>
</div>
</div>

<div id="outline-container-orgf34f080" class="outline-5">
<h5 id="orgf34f080"><span class="section-number-5">8.1.1.12</span> <code>&lt;&lt;aba_ratio_tau_vs_kappa_g_script&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-8-1-1-12">
<div class="org-src-container">
<pre class="src src-C" id="org0eea7e3">char file4gp[512];
//define a macro generating the gnuplot script
#define mk_gp_script(p_name)\
  strcpy(file4gp,output);\
  strcat(file4gp,"_tau_vs_" #p_name "_kappa");\
  strcpy(out,output);\
  strcat(out,"_tau_vs_" #p_name "_kappa.gp");\
  fp = fopen(out,"w");\
  fprintf(fp,\
    "unset key\n"\
    "set grid\n"\
    "set ylabel 'τ (s)'\n"\
    "set xlabel '" #p_name " κ_Fura' noenhanced\n"\
    "set title 'Data from %s' noenhanced\n"\
    "set xrange [-1000&lt;*:*]\n"\
    "plot '%s' index 0 using 1:2:(1.96*$3) linecolor rgb 'red' with yerrorbars,\\\n",\
	  filename,file4gp);\
  fprintf(fp,\
	  "'' index 1 using 1:2 with lines linecolor rgb 'black',\\\n");\
  fprintf(fp,\
	  "'' index 1 using 1:3 with lines linecolor rgb 'blue' lt 'dotted',\\\n");\
  fprintf(fp,\
	  "'' index 1 using 1:4 with lines linecolor rgb 'blue' lt 'dotted'");\
  fclose(fp);\

#define mk_gp_script_robust(p_name)\
  strcpy(file4gp,output);\
  strcat(file4gp,"_tau_vs_" #p_name "_kappa_robust");\
  strcpy(out,output);\
  strcat(out,"_tau_vs_" #p_name "_kappa_robust.gp");\
  fp = fopen(out,"w");\
  fprintf(fp,\
    "unset key\n"\
    "set grid\n"\
    "set ylabel 'τ (s)'\n"\
    "set xlabel '" #p_name " κ_Fura' noenhanced\n"\
    "set title 'Data from %s' noenhanced\n"\
    "plot '%s' index 0 using 1:2:(1.96*$3) linecolor rgb 'red' with yerrorbars,\\\n",\
	  filename,file4gp);\
  fprintf(fp,\
	  "'' index 1 using 1:2 with lines linecolor rgb 'black',\\\n");\
  fprintf(fp,\
	  "'' index 1 using 1:3 with lines linecolor rgb 'black' lt 'dotted',\\\n");\
  fprintf(fp,\
	  "'' index 1 using 1:4 with lines linecolor rgb 'black' lt 'dotted',\\\n");\
  fprintf(fp,\
	  "'' index 1 using 1:5 with lines linecolor rgb 'blue',\\\n");\
  fprintf(fp,\
	  "'' index 1 using 1:6 with lines linecolor rgb 'blue' lt 'dotted',\\\n");\
  fprintf(fp,\
	  "'' index 1 using 1:7 with lines linecolor rgb 'blue' lt 'dotted'");\
  fclose(fp);\

if (do_robust) {
mk_gp_script_robust(mean)

mk_gp_script_robust(min)

mk_gp_script_robust(max)
} else {
mk_gp_script(mean)

mk_gp_script(min)

mk_gp_script(max)
}

</pre>
</div>
</div>
</div>


<div id="outline-container-org095766c" class="outline-5">
<h5 id="org095766c"><span class="section-number-5">8.1.1.13</span> <code>&lt;&lt;wls_fit&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-8-1-1-13">
<div class="org-src-container">
<pre class="src src-C" id="org6bf0305">/// @brief Performs a weighted linear regression and prints results
///        to `stderr` and to a file whose prefix is built from
///        `output`.
///
/// @returns 0 if everything is fine
int wls_fit(const gsl_vector * kappa, ///&lt; [in] vector of kappa values.  
	    mono_exp_fit_res * fit_res, ///&lt; [in] vector of mono_exp_fit_res.
	    size_t n_stim, ///&lt; [in] the number of stimulation.
	    char * filename, ///&lt; Name of file containing the data
	    char * output, ///&lt; Prefix of file name where results are written
	    gsl_rng * rng, ///&lt; Pointer to a gsl_rng
	    int what, ///&lt; What is processed? 0 = mean, 1 = min, 2 = max
	    size_t *stim ///&lt; [in] Vector of indexes of used stimulation
  ) 
{
  fprintf(stderr,"******************************************\n");
  if (what==0)
    fprintf(stderr,"* Doing tau vs mean kappa_Fura regression *\n");
  if (what==1)
    fprintf(stderr,"* Doing tau vs min kappa_Fura regression *\n");
  if (what==2)
    fprintf(stderr,"* Doing tau vs max kappa_Fura regression *\n");
  fprintf(stderr,"******************************************\n");

  gsl_vector * c = gsl_vector_alloc(2);
  gsl_matrix * cov = gsl_matrix_alloc(2,2);
  double chisq,tss;
  // Prepare data for fit
  gsl_vector * tau = gsl_vector_alloc(n_stim); // The dependent variable
  gsl_vector * w = gsl_vector_alloc(n_stim); // The weight of the above
  for (size_t s_idx=0; s_idx&lt;n_stim; s_idx++) {
    gsl_vector_set(tau, s_idx, (fit_res[s_idx]).tau);
    gsl_vector_set(w, s_idx, 1.0/gsl_pow_2((fit_res[s_idx]).tau_se));
  }
  // Get total sum of squares (TSS)
  tss = gsl_stats_wtss(w-&gt;data,1,tau-&gt;data,1,tau-&gt;size);
  // Allocate design matrix
  gsl_matrix * X = gsl_matrix_alloc(n_stim,2);
  // Fill design matrix
  for (size_t s_idx=0; s_idx&lt;n_stim; s_idx++) {
    gsl_matrix_set(X,s_idx,0,1.0);
    gsl_matrix_set(X,s_idx,1,gsl_vector_get(kappa,s_idx));
  }
  gsl_multifit_linear_workspace * work = gsl_multifit_linear_alloc (n_stim, 2);
  gsl_multifit_wlinear (X, w, tau, c, cov, &amp;chisq, work);
  gsl_multifit_linear_free (work);
  

  double kappa_S_MC[NREP];
  double beta0 = BETA0(c);
  double beta1 = BETA1(c);
  double cov00 = BETA0_VAR(cov);
  double cov11 = BETA1_VAR(cov);
  double beta0_se = BETA0_SE(cov);
  double kappa_S = kappa_s(c);
  double kappa_S_se = kappa_s_se(c,cov);
  double se11=BETA1_SE(cov);
  double rho=gsl_matrix_get(cov,0,1)/beta0_se/se11;
  for (size_t rep_idx=0; rep_idx&lt;NREP; rep_idx++) {
    double num,denom;
    gsl_ran_bivariate_gaussian(rng,beta0_se,se11,rho,&amp;num,&amp;denom);
    num+=beta0;
    denom+=beta1;
    //double num=(beta0+gsl_ran_gaussian_ziggurat(rng,beta0_se));
    //double denom=(beta1+gsl_ran_gaussian_ziggurat(rng,se11));
    kappa_S_MC[rep_idx] = num/denom-1.0;
  }
  gsl_sort(kappa_S_MC,1,NREP);
  double kappa_S_l95=kappa_S_MC[(size_t)(0.025*NREP-1)];
  double kappa_S_u95=kappa_S_MC[(size_t)(0.975*NREP-1)];
  double kappa_S_l99=kappa_S_MC[(size_t)(0.005*NREP-1)];
  double kappa_S_u99=kappa_S_MC[(size_t)(0.995*NREP-1)];

  fprintf(stderr,"Best fit: tau = %g + %g kappa_Fura\n",beta0 , beta1 );
  fprintf(stderr,"Covariance matrix:\n");
  fprintf(stderr,"[ %+.5e, %+.5e  \n", cov00, gsl_matrix_get(cov,0,1));
  fprintf(stderr,"  %+.5e, %+.5e  ]\n", gsl_matrix_get(cov,1,0), cov11);
  fprintf(stderr,"Total sum of squares (TSS) = %g\n", tss);
  fprintf(stderr,"chisq (Residual sum of squares, RSS) = %g\n", chisq);
  double p_larger = gsl_cdf_chisq_Q(chisq,n_stim-2);
  fprintf(stderr,"Probability of observing a larger of equal RSS per DOF under the null hypothesis: %g\n",p_larger);
  fprintf(stderr,"R squared (1-RSS/TSS) = %g\n", 1 - chisq / tss);
  fprintf(stderr,"Estimated gamma/v with standard error: %g +/- %g\n",
	 gamma_over_v_hat(c), gamma_over_v_se(c,cov));
  fprintf(stderr,"Estimated kappa_S with standard error (using error propagation): %g +/- %g\n",
	  kappa_S, kappa_S_se);
  fprintf(stderr,"kappa_S confidence intervals based on parametric bootstrap\n");
  fprintf(stderr,"0.95 CI for kappa_S: [%g,%g]\n",kappa_S_l95,kappa_S_u95);
  fprintf(stderr,"0.99 CI for kappa_S: [%g,%g]\n",kappa_S_l99,kappa_S_u99);
  fprintf(stderr,"******************************************\n");
  if (what==0)
    fprintf(stderr,"* tau vs mean kappa_Fura regression done *\n");
  if (what==1)
    fprintf(stderr,"* tau vs min kappa_Fura regression done  *\n");
  if (what==2)
    fprintf(stderr,"* tau vs max kappa_Fura regression done  *\n");
  fprintf(stderr,"******************************************\n");

  // Print to file
  char out[512];
  strcpy(out,output);
  if (what==0)
    strcat(out,"_tau_vs_mean_kappa");
  if (what==1)
    strcat(out,"_tau_vs_min_kappa");
  if (what==2)
    strcat(out,"_tau_vs_max_kappa");
  FILE *fp = fopen(out,"w");
  if (what==0)
    fprintf(fp,"# τ vs mean κ linear regression for data set %s\n",filename);
  if (what==1)
    fprintf(fp,"# τ vs min κ linear regression for data set %s\n",filename);
  if (what==2)
    fprintf(fp,"# τ vs max κ linear regression for data set %s\n",filename);
  fprintf(fp,"# Using stimulation: %d",(int) stim[0]);
  for (size_t s_idx=1; s_idx&lt;n_stim; s_idx++)
    fprintf(fp,", %d", (int) stim[s_idx]);
  fprintf(fp,"\n");
  fprintf(fp,"# Best fit: tau = %g + %g kappa_Fura\n",beta0 , beta1 );
  fprintf(fp,"# Covariance matrix:\n");
  fprintf(fp,"# [ %+.5e, %+.5e  \n", cov00, gsl_matrix_get(cov,0,1));
  fprintf(fp,"#   %+.5e, %+.5e  ]\n", gsl_matrix_get(cov,1,0), cov11);
  fprintf(fp,"# Total sum of squares (TSS) = %g\n", tss);
  fprintf(fp,"# chisq (Residual sum of squares, RSS) = %g\n", chisq);
  fprintf(fp,"# Probability of observing a larger of equal RSS per DOF under the null hypothesis: %g\n",p_larger);
  fprintf(fp,"# R squared (1-RSS/TSS) = %g\n", 1 - chisq / tss);
  fprintf(fp,"# Estimated gamma/v with standard error: %g +/- %g\n",
	  gamma_over_v_hat(c), gamma_over_v_se(c,cov));
  fprintf(fp,"# Estimates kappa_S with standard error (using error propagation): %g +/- %g\n",
	  kappa_S, kappa_S_se);
  fprintf(fp,"# kappa_S confidence intervals based on parametric bootstrap\n");
  fprintf(fp,"# 0.95 CI for kappa_S: [%g,%g]\n",kappa_S_l95,kappa_S_u95);
  fprintf(fp,"# 0.99 CI for kappa_S: [%g,%g]\n",kappa_S_l99,kappa_S_u99);
  fprintf(fp,"\n\n");
  fprintf(fp,"# The data\n"
	  "# κ_Fura  τ   τ_SE\n");		
  for (size_t s_idx=0; s_idx&lt;n_stim; s_idx++)	
    fprintf(fp,"%g %g %g\n",
	    gsl_vector_get(kappa,s_idx),	
	    gsl_vector_get(tau,s_idx),		
	    (fit_res[s_idx]).tau_se);		
  fprintf(fp,"\n\n");
  fprintf(fp,
	  "# The fitted data\n"
	  "# Preticted values with lower and upper bounds of 0.95 CI\n"
	  "# κ_Fura  τ   τ_lwr  τ_upr\n");
  double kappa_bd = 0.0;
  if (kappa_S &gt; 0.0)
    kappa_bd = 1.25*kappa_S+1;
  // double kappa_range = 1.05*gsl_vector_get(kappa,n_stim-1)+kappa_S_u99+1; 
  double kappa_range = 1.05*gsl_vector_get(kappa,n_stim-1)+kappa_bd; 
  double delta_kappa = kappa_range/250;

  gsl_vector * kappa_v = gsl_vector_alloc(2);
  gsl_vector_set(kappa_v,0,1.0);
  for (size_t i=0; i&lt;250; i++) {
    double kappaP = -kappa_bd+delta_kappa*i;
    gsl_vector_set(kappa_v,1,kappaP);
    double tauP,tauP_err;
    gsl_multifit_linear_est(kappa_v, c, cov, &amp;tauP, &amp;tauP_err);
    fprintf(fp,
	    "%g %g %g %g\n",
	    kappaP, tauP,
	    tauP-1.96*tauP_err,
	    tauP+1.96*tauP_err);
  }
  gsl_vector_free(kappa_v);
  fclose(fp);
  
  gsl_vector_free(tau);
  gsl_vector_free(w);
  gsl_vector_free(c);
  gsl_matrix_free(X);
  gsl_matrix_free(cov);
  
  return 0;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgda4391b" class="outline-5">
<h5 id="orgda4391b"><span class="section-number-5">8.1.1.14</span> <code>&lt;&lt;robust_fit&gt;&gt;</code></h5>
<div class="outline-text-5" id="text-8-1-1-14">
<div class="org-src-container">
<pre class="src src-C" id="org008f97c">/// @brief Performs a robust linear regression and prints results
///        to `stderr` and to a file whose prefix is built from
///        `output`.
///
/// @returns 0 if everything is fine
int robust_fit(const gsl_vector * kappa, ///&lt; [in] vector of kappa values.  
	       mono_exp_fit_res * fit_res, ///&lt; [in] vector of mono_exp_fit_res.
	       size_t n_stim, ///&lt; [in] the number of stimulation.
	       char * filename, ///&lt; Name of file containing the data
	       char * output, ///&lt; Prefix of file name where results are written
	       gsl_rng * rng, ///&lt; Pointer to a gsl_rng
	       int what, ///&lt; What is processed? 0 = mean, 1 = min, 2 = max
	       size_t *stim ///&lt; [in] Vector of indexes of used stimulation
  ) 
{
  fprintf(stderr,"\n***********************************************************\n");
  if (what==0)
    fprintf(stderr,"* Doing tau vs mean kappa_Fura robust bi-square regression *\n");
  if (what==1)
    fprintf(stderr,"* Doing tau vs min kappa_Fura robust bi-square regression *\n");
  if (what==2)
    fprintf(stderr,"* Doing tau vs max kappa_Fura robust bi-square regression *\n");
  fprintf(stderr,"***********************************************************\n");

  gsl_vector * c = gsl_vector_alloc(2);
  gsl_vector * c_ols = gsl_vector_alloc(2);
  gsl_matrix * cov = gsl_matrix_alloc(2,2);
  gsl_matrix * cov_ols = gsl_matrix_alloc(2,2);
  double tss;
  // Find out tau estimation with largest variance
  double max_var = 0.0;
  for (size_t s_idx=0; s_idx&lt;n_stim; s_idx++) {
    double var = gsl_pow_2((fit_res[s_idx]).tau_se);
    if (var &gt; max_var)
      max_var = var;
  }
  // Get the number of pseudo observations
  size_t pseudo_n_stim = 0;
  for (size_t s_idx=0; s_idx&lt;n_stim; s_idx++) {
    double var = gsl_pow_2((fit_res[s_idx]).tau_se);
    pseudo_n_stim += (size_t) round(max_var/var);
  }
  // Prepare pseudo data for fit
  // Pseudo data are obtained from actual data by
  // replicating some observations in order to have
  // the right standard error ratio
  gsl_vector * tau = gsl_vector_alloc(pseudo_n_stim);
  gsl_vector * pkappa = gsl_vector_alloc(pseudo_n_stim);
  size_t p_idx = 0;
  for (size_t s_idx=0; s_idx&lt;n_stim; s_idx++) {
    double var = gsl_pow_2((fit_res[s_idx]).tau_se);
    size_t ncp = (size_t) round(max_var/var);
    double tau_value = (fit_res[s_idx]).tau;
    double kappa_value = gsl_vector_get(kappa,s_idx);  
    for (size_t c_idx=0; c_idx &lt; ncp; c_idx++) {
      gsl_vector_set(tau,p_idx,tau_value);
      gsl_vector_set(pkappa,p_idx,kappa_value);
      p_idx += 1;
    }
  }
  // Get total sum of squares (TSS)
  tss = gsl_stats_tss(tau-&gt;data,1,tau-&gt;size);
  // Allocate design matrix
  gsl_matrix * X = gsl_matrix_alloc(pseudo_n_stim,2);
  // Fill design matrix
  for (size_t s_idx=0; s_idx&lt;pseudo_n_stim; s_idx++) {
    gsl_matrix_set(X,s_idx,0,1.0);
    gsl_matrix_set(X,s_idx,1,gsl_vector_get(pkappa,s_idx));
  }
  // Do robust with bi-square weight function
  gsl_multifit_robust_workspace * work = gsl_multifit_robust_alloc (gsl_multifit_robust_bisquare,
								    pseudo_n_stim, 2);
  gsl_multifit_robust (X, tau, c, cov, work);
  gsl_multifit_robust_stats rstats = gsl_multifit_robust_statistics(work);
  double chisq = rstats.sse;
  double Rsq = rstats.Rsq;
  gsl_multifit_robust_free (work);

  // Do OLS fit
  gsl_multifit_robust_workspace * work_ols = gsl_multifit_robust_alloc (gsl_multifit_robust_ols,
									pseudo_n_stim, 2);
  gsl_multifit_robust (X, tau, c_ols, cov_ols, work_ols);
  gsl_multifit_robust_stats rstats_ols = gsl_multifit_robust_statistics(work_ols);
  double chisq_ols = rstats_ols.sse;
  double Rsq_ols = rstats_ols.Rsq;
  gsl_multifit_robust_free (work_ols);
  

  double kappa_S_MC[NREP];
  double beta0 = BETA0(c);
  double beta1 = BETA1(c);
  double cov00 = BETA0_VAR(cov);
  double cov11 = BETA1_VAR(cov);
  double beta0_se = BETA0_SE(cov);
  double kappa_S = kappa_s(c);
  double kappa_S_se = kappa_s_se(c,cov);
  double se11=BETA1_SE(cov);
  for (size_t rep_idx=0; rep_idx&lt;NREP; rep_idx++) {
    double num=(beta0+gsl_ran_gaussian_ziggurat(rng,beta0_se));
    double denom=(beta1+gsl_ran_gaussian_ziggurat(rng,se11));
    kappa_S_MC[rep_idx] = num/denom-1.0;
  }
  gsl_sort(kappa_S_MC,1,NREP);
  double kappa_S_l95=kappa_S_MC[(size_t)(0.025*NREP-1)];
  double kappa_S_u95=kappa_S_MC[(size_t)(0.975*NREP-1)];
  double kappa_S_l99=kappa_S_MC[(size_t)(0.005*NREP-1)];
  double kappa_S_u99=kappa_S_MC[(size_t)(0.995*NREP-1)];

  fprintf(stderr,"Best fit: tau = %g + %g kappa_Fura\n",beta0 , beta1 );
  fprintf(stderr,"Covariance matrix:\n");
  fprintf(stderr,"[ %+.5e, %+.5e  \n", cov00, gsl_matrix_get(cov,0,1));
  fprintf(stderr,"  %+.5e, %+.5e  ]\n", gsl_matrix_get(cov,1,0), cov11);
  fprintf(stderr,"Total sum of squares (TSS) = %g\n", tss);
  fprintf(stderr,"chisq (Residual sum of squares, RSS) = %g\n", chisq);
  fprintf(stderr,"R squared (1-RSS/TSS) = %g\n", Rsq);
  fprintf(stderr,"Estimated gamma/v with standard error: %g +/- %g\n",
	  gamma_over_v_hat(c), gamma_over_v_se(c,cov));
  fprintf(stderr,"Estimated kappa_S with standard error (using error propagation): %g +/- %g\n",
	  kappa_S, kappa_S_se);
  fprintf(stderr,"kappa_S confidence intervals based on parametric bootstrap\n");
  fprintf(stderr,"0.95 CI for kappa_S: [%g,%g]\n",kappa_S_l95,kappa_S_u95);
  fprintf(stderr,"0.99 CI for kappa_S: [%g,%g]\n",kappa_S_l99,kappa_S_u99);
  fprintf(stderr,"***********************************************************\n");
  if (what==0)
    fprintf(stderr,"* tau vs mean kappa_Fura robust bi-square regression done *\n");
  if (what==1)
    fprintf(stderr,"* tau vs min kappa_Fura robust bi-square regression done  *\n");
  if (what==2)
    fprintf(stderr,"* tau vs max kappa_Fura robust bi-square regression done  *\n");
  fprintf(stderr,"***********************************************************\n");

  // Print OLS results to stderr
  fprintf(stderr,"\n****************************************************\n");
  if (what==0)
    fprintf(stderr,"* Doing tau vs mean kappa_Fura ordinary regression *\n");
  if (what==1)
    fprintf(stderr,"* Doing tau vs min kappa_Fura ordinary regression *\n");
  if (what==2)
    fprintf(stderr,"* Doing tau vs max kappa_Fura ordinary regression *\n");
  fprintf(stderr,"*****************************************************\n");

  double beta0_ols = BETA0(c_ols);
  double beta1_ols = BETA1(c_ols);
  double cov00_ols = BETA0_VAR(cov_ols);
  double cov11_ols = BETA1_VAR(cov_ols);
  double beta0_ols_se = BETA0_SE(cov_ols);
  double kappa_S_ols = kappa_s(c_ols);
  double kappa_S_ols_se = kappa_s_se(c_ols,cov_ols);
  double se11_ols=sqrt(cov11_ols);
  for (size_t rep_idx=0; rep_idx&lt;NREP; rep_idx++) {
    double num=(beta0_ols+gsl_ran_gaussian_ziggurat(rng,beta0_ols_se));
    double denom=(beta1_ols+gsl_ran_gaussian_ziggurat(rng,se11_ols));
    kappa_S_MC[rep_idx] = num/denom-1.0;
  }
  gsl_sort(kappa_S_MC,1,NREP);
  double kappa_S_ols_l95=kappa_S_MC[(size_t)(0.025*NREP-1)];
  double kappa_S_ols_u95=kappa_S_MC[(size_t)(0.975*NREP-1)];
  double kappa_S_ols_l99=kappa_S_MC[(size_t)(0.005*NREP-1)];
  double kappa_S_ols_u99=kappa_S_MC[(size_t)(0.995*NREP-1)];

  fprintf(stderr,"Best fit: tau = %g + %g kappa_Fura\n",beta0_ols , beta1_ols );
  fprintf(stderr,"Covariance matrix:\n");
  fprintf(stderr,"[ %+.5e, %+.5e  \n", cov00_ols, gsl_matrix_get(cov_ols,0,1));
  fprintf(stderr,"  %+.5e, %+.5e  ]\n", gsl_matrix_get(cov_ols,1,0), cov11_ols);
  fprintf(stderr,"Total sum of squares (TSS) = %g\n", tss);
  fprintf(stderr,"chisq (Residual sum of squares, RSS) = %g\n", chisq_ols);
  fprintf(stderr,"R squared (1-RSS/TSS) = %g\n", Rsq_ols);
  fprintf(stderr,"Estimated gamma/v with standard error: %g +/- %g\n",
	  gamma_over_v_hat(c_ols), gamma_over_v_se(c_ols,cov_ols));
  fprintf(stderr,"Estimated kappa_S with standard error (using error propagation): %g +/- %g\n",
	  kappa_S_ols, kappa_S_ols_se);
  fprintf(stderr,"kappa_S confidence intervals based on parametric bootstrap\n");
  fprintf(stderr,"0.95 CI for kappa_S: [%g,%g]\n",kappa_S_ols_l95,kappa_S_ols_u95);
  fprintf(stderr,"0.99 CI for kappa_S: [%g,%g]\n",kappa_S_ols_l99,kappa_S_ols_u99);
  fprintf(stderr,"****************************************************\n");
  if (what==0)
    fprintf(stderr,"* tau vs mean kappa_Fura ordinary regression done *\n");
  if (what==1)
    fprintf(stderr,"* tau vs min kappa_Fura ordinary regression done  *\n");
  if (what==2)
    fprintf(stderr,"* tau vs max kappa_Fura ordinary regression done  *\n");
  fprintf(stderr,"****************************************************\n");
  
  // Print to file
  char out[512];
  strcpy(out,output);
  if (what==0)
    strcat(out,"_tau_vs_mean_kappa_robust");
  if (what==1)
    strcat(out,"_tau_vs_min_kappa_robust");
  if (what==2)
    strcat(out,"_tau_vs_max_kappa_robust");
  FILE *fp = fopen(out,"w");
  if (what==0)
    fprintf(fp,"# τ vs mean κ robust regression for data set %s\n",filename);
  if (what==1)
    fprintf(fp,"# τ vs min κ robust regression for data set %s\n",filename);
  if (what==2)
    fprintf(fp,"# τ vs max κ robust regression for data set %s\n",filename);
  fprintf(fp,"# Using stimulation: %d",(int) stim[0]);
  for (size_t s_idx=1; s_idx&lt;n_stim; s_idx++)
    fprintf(fp,", %d", (int) stim[s_idx]);
  fprintf(fp,"\n");
  fprintf(fp,"# Results obtained with robust bi-square regression:");
  fprintf(fp,"# Best fit: tau = %g + %g kappa_Fura\n",beta0 , beta1 );
  fprintf(fp,"# Covariance matrix:\n");
  fprintf(fp,"# [ %+.5e, %+.5e  \n", cov00, gsl_matrix_get(cov,0,1));
  fprintf(fp,"#   %+.5e, %+.5e  ]\n", gsl_matrix_get(cov,1,0),cov11);
  fprintf(fp,"# Total sum of squares (TSS) = %g\n", tss);
  fprintf(fp,"# chisq (Residual sum of squares, RSS) = %g\n", chisq);
  fprintf(fp,"# R squared (1-RSS/TSS) = %g\n", Rsq);
  fprintf(fp,"# Estimated gamma/v with standard error: %g +/- %g\n",
	gamma_over_v_hat(c), gamma_over_v_se(c,cov));
  fprintf(fp,"# Estimates kappa_S with standard error (using error propagation): %g +/- %g\n",
	  kappa_S, kappa_S_se);
  fprintf(fp,"# kappa_S confidence intervals based on parametric bootstrap\n");
  fprintf(fp,"# 0.95 CI for kappa_S: [%g,%g]\n",kappa_S_l95,kappa_S_u95);
  fprintf(fp,"# 0.99 CI for kappa_S: [%g,%g]\n",kappa_S_l99,kappa_S_u99);
  fprintf(fp,"\n\n");
  fprintf(fp,"# Results obtained with ordinary regression:\n");
  fprintf(fp,"# Best fit: tau = %g + %g kappa_Fura\n",beta0_ols , beta1_ols );
  fprintf(fp,"# Covariance matrix:\n");
  fprintf(fp,"# [ %+.5e, %+.5e  \n", cov00_ols, gsl_matrix_get(cov_ols,0,1));
  fprintf(fp,"#   %+.5e, %+.5e  ]\n", gsl_matrix_get(cov_ols,1,0), cov11_ols);
  fprintf(fp,"# Total sum of squares (TSS) = %g\n", tss);
  fprintf(fp,"# chisq (Residual sum of squares, RSS) = %g\n", chisq_ols);
  fprintf(fp,"# R squared (1-RSS/TSS) = %g\n", Rsq_ols);
  fprintf(fp,"# Estimated gamma/v with standard error: %g +/- %g\n",
	  gamma_over_v_hat(c_ols), gamma_over_v_se(c_ols,cov_ols));
  fprintf(fp,"# Estimates kappa_S with standard error (using error propagation): %g +/- %g\n",
	  kappa_S_ols, kappa_S_ols_se);
  fprintf(fp,"# kappa_S confidence intervals based on parametric bootstrap\n");
  fprintf(fp,"# 0.95 CI for kappa_S: [%g,%g]\n",kappa_S_ols_l95,kappa_S_ols_u95);
  fprintf(fp,"# 0.99 CI for kappa_S: [%g,%g]\n",kappa_S_ols_l99,kappa_S_ols_u99);
  fprintf(fp,"\n\n");
  
  fprintf(fp,"# The data\n"
	  "# κ_Fura  τ   τ_SE\n");		
  for (size_t s_idx=0; s_idx&lt;n_stim; s_idx++)	
    fprintf(fp,"%g %g %g\n",
	    gsl_vector_get(kappa,s_idx),	
	    (fit_res[s_idx]).tau,		
	    (fit_res[s_idx]).tau_se);		
  fprintf(fp,"\n\n");
  fprintf(fp,
	  "# The fitted data\n"
	  "# Preticted values with lower and upper bounds of 0.95 CI and the two fitting methods\n"
	  "# κ_Fura  τ   τ_lwr  τ_upr  τ_ols  τ_ols_lwr  τ_ols_upr\n");
  double kappa_range = 1.05*gsl_vector_get(pkappa,pseudo_n_stim-1)+kappa_S_u99+1; 
  double delta_kappa = kappa_range/250;

  gsl_vector * kappa_v = gsl_vector_alloc(2);
  gsl_vector_set(kappa_v,0,1.0);
  for (size_t i=0; i&lt;250; i++) {
    double kappaP = -kappa_S_u99-1+delta_kappa*i;
    gsl_vector_set(kappa_v,1,kappaP);
    double tauP,tauP_err;
    gsl_multifit_robust_est(kappa_v, c, cov, &amp;tauP, &amp;tauP_err);
    double tauP_ols,tauP_ols_err;
    gsl_multifit_robust_est(kappa_v, c_ols, cov_ols, &amp;tauP_ols, &amp;tauP_ols_err);
    fprintf(fp,
	    "%g %g %g %g %g %g %g\n",
	    kappaP, tauP,
	    tauP-1.96*tauP_err,
	    tauP+1.96*tauP_err,
	    tauP_ols,
	    tauP_ols-1.96*tauP_ols_err,
	    tauP_ols+1.96*tauP_ols_err);
  }
  gsl_vector_free(kappa_v);
  fclose(fp);
  
  gsl_vector_free(tau);
  gsl_vector_free(pkappa);
  gsl_vector_free(c);
  gsl_vector_free(c_ols);
  gsl_matrix_free(X);
  gsl_matrix_free(cov);
  gsl_matrix_free(cov_ols);
  
  return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org650a3f2" class="outline-5">
<h5 id="org650a3f2"><span class="section-number-5">8.1.1.15</span> <code>aba_ratio</code> compilation</h5>
<div class="outline-text-5" id="text-8-1-1-15">
<div class="org-src-container">
<pre class="src src-sh" id="orgaad03b2">cd code &amp;&amp; make aba_ratio
</pre>
</div>

<pre class="example">
cc -g -Wall -std=gnu11    -c -o aba_ratio.o aba_ratio.c
cc aba_ratio.o libabaa.a -lhdf5 -lhdf5_hl -lgsl -lgslcblas -lm  -o aba_ratio
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org42e3831" class="outline-3">
<h3 id="org42e3831"><span class="section-number-3">8.2</span> Using <code>aba_ratio</code></h3>
<div class="outline-text-3" id="text-8-2">
</div>
<div id="outline-container-orgbf804fc" class="outline-4">
<h4 id="orgbf804fc"><span class="section-number-4">8.2.1</span> Getting help</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
What to do if we forget how to use the program?
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgf98a6ed">./code/aba_ratio --help
</pre>
</div>

<pre class="example">
usage: ./code/aba_ratio -i --input=string [-o --output=string] ...
          ... [-s --stim=integer,integer,integer] ...
          ... [-m --maxiter=integer] [-b --baseline_length=integer] ...
          ... [-f --start_fit=real] [-r --robust] [-g --graphic]

  -i --input &lt;character string&gt;: data file name (e.g. data_paper/data_beta_escin/DA_121219_E1.h5)
  -o --output &lt;character string&gt;: output file name prefix (e.g. 'DA_121219_E1_s1_ratio');
       if not specificied, the '.h5' is stripped from 'input' and '_aba' is added
  -s --stim &lt;positive integer&gt;: coma separated list of stimulations to fit
       (default all stimulation considered).
  -m --max_iter &lt;positive integer&gt;: maximal number of iterations performed by
       the nonlinear least-squares solver (default 50).
  -b --baseline_length &lt;positive integer&gt;: baseline length in samples (default 15).
  -f --start_fit &lt;positive real&gt;: where decay fit starts, if &gt; 1 interpreted as the
       number of samples after the peak, if 0&lt;f&lt;1 interpreted as the remaining
       fraction of the jump and fitting starts when the transient reaches that level.
       Default value: 0.5.
  -r --robust: if set, a robust linear regression of tau vs kappa_Fura is performed
       using a bi-square weight function.
  -g --graphics: if set, gnuplot script files are generated.

 The program opens 'input' file, get the loading curve and prints the result to a file
 named output_loading_curve; then for every stimulation specified in the 'stim' list 
 it computes the ratiometric estimator from the raw data
 and fits the following model to it: Ca = baseline + delta * exp (-(t-t0)/tau)
 where t0 is the time on the decay phase at which the fit starts (set by parameter 'f').
 A constant is also fitted to the baseline region: Ca = baseline.
 Standard errors for the ratiometric estimator are obtained by Monte-Carlo simulation.
 While the program performs the least-squares optimization relevant information get printed
 to the stderr. The ratiometric estimator and its standard error are printed to a text
 file named 'output_CaRatio_sX' (where 'X' stands for the stimulation number. The fitted
 parameters, fitted values and residuals are printed to a text file named 'output_RatioFit_sX'.
 If 'g' is selected, a gnuplot script file whose name is the 'output_YY_sX.gp' where 'YY' is
 either 'loading_curve' or 'RatioFit' 'is generated. A graphical display
 of the result can then be obtained with: gnuplot -persist 'output_YY_sX.gp'

 Once each specified stimulation has been fitted, a regression of tau vs kappa is performed
 using three different values for kappa: the mean value during the fitted part of the transient,
 the minimal and the maximal values. Information and fit results get printed to the 'stderr' as
 well as to files named 'output_aba_tau_vs_mean/min/max_kappa', if option '-g' is set, gnuplot
 script files are also generated with names 'output_aba_tau_vs_mean/min/max_kappa.gp'

 When a robust linear regression is requested (by using optional argument '-r' or '--robust'
 when calling the program), a bi-square weight function is used (see:
 https://www.gnu.org/software/gsl/doc/html/lls.html#robust-linear-regression). Since
 the robust methods implemented in the GSL do not allow for the use of the standard errors on
 the dependent variable, we multiply the observations in order to have approximately the
 right standard error ratio: that is, if an observation has a standard error of 0.13 and
 another one has 0.091, we will include two identical copies of the second since (0.13/0.091)^2
 is approximately 2. This use of multiple copies is reported to the user.

</pre>
</div>
</div>


<div id="outline-container-org45f85d5" class="outline-4">
<h4 id="org45f85d5"><span class="section-number-4">8.2.2</span> Running <code>aba_ratio</code></h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
We run the program on data set <code>DA/DA_121219_E1.h5</code> with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgfb9478e">./code/aba_ratio -i data_paper/data_beta_escin/DA_121219_E1.h5 -g 
</pre>
</div>

<pre class="example">
**********************************
* Doing now stimulation 1
**********************************
iter  0: baseline = 0.0586, delta = 0.1231, tau = 16.5000, RSS = 22560.7721
iter  1: baseline = 0.0597, delta = 0.0565, tau = 5.2748, RSS = 654.5754
iter  2: baseline = 0.0583, delta = 0.0629, tau = 3.8027, RSS = 413.2581
iter  3: baseline = 0.0585, delta = 0.0784, tau = 3.0453, RSS = 257.7129
iter  4: baseline = 0.0586, delta = 0.0973, tau = 2.5935, RSS = 154.7876
iter  5: baseline = 0.0588, delta = 0.1096, tau = 2.4025, RSS = 129.2228
iter  6: baseline = 0.0588, delta = 0.1133, tau = 2.3489, RSS = 127.5931
iter  7: baseline = 0.0589, delta = 0.1138, tau = 2.3401, RSS = 127.5715
iter  8: baseline = 0.0589, delta = 0.1138, tau = 2.3393, RSS = 127.5713
iter  9: baseline = 0.0589, delta = 0.1138, tau = 2.3392, RSS = 127.5713
iter 10: baseline = 0.0589, delta = 0.1138, tau = 2.3392, RSS = 127.5713
iter 11: baseline = 0.0589, delta = 0.1138, tau = 2.3392, RSS = 127.5713
iter 12: baseline = 0.0589, delta = 0.1138, tau = 2.3392, RSS = 127.5713
Fitted model Ca = baseline+delta*exp(-(t-t0)/tau)
Summary from method 'trust-region/levenberg-marquardt'
number of iterations: 12
function evaluations: 56
Jacobian evaluations: 0
reason for stopping: small step size
initial RSS = 22560.772065
final   RSS = 127.571349

Number of observation: 181
Number of degrees of freedom: 178
Baseline length: 15
Fit started from point 34
Estimated baseline 0.058857 and standard error 0.000547938
Estimated delta 0.113819 and standard error 0.00339631
Estimated tau 2.33918 and standard error 0.0947737
RSS per degree of freedom: 0.716693
Probability of observing a larger of equal RSS per DOF under the null hypothesis: 0.998365

**********************************
* Stimulation 1 done
**********************************

**********************************
* Doing now stimulation 2
**********************************
iter  0: baseline = 0.0505, delta = 0.0755, tau = 15.7000, RSS = 17127.2911
iter  1: baseline = 0.0532, delta = 0.0524, tau = 1.1877, RSS = 3258.8071
iter  2: baseline = 0.0563, delta = 0.0627, tau = 3.2968, RSS = 410.4336
iter  3: baseline = 0.0530, delta = 0.0795, tau = 3.0225, RSS = 169.9101
iter  4: baseline = 0.0530, delta = 0.0798, tau = 3.0718, RSS = 168.2218
iter  5: baseline = 0.0530, delta = 0.0798, tau = 3.0738, RSS = 168.2212
iter  6: baseline = 0.0530, delta = 0.0797, tau = 3.0739, RSS = 168.2212
iter  7: baseline = 0.0530, delta = 0.0797, tau = 3.0739, RSS = 168.2212
iter  8: baseline = 0.0530, delta = 0.0797, tau = 3.0739, RSS = 168.2212
iter  9: baseline = 0.0530, delta = 0.0797, tau = 3.0739, RSS = 168.2212
Fitted model Ca = baseline+delta*exp(-(t-t0)/tau)
Summary from method 'trust-region/levenberg-marquardt'
number of iterations: 9
function evaluations: 43
Jacobian evaluations: 0
reason for stopping: small step size
initial RSS = 17127.291078
final   RSS = 168.221246

Number of observation: 173
Number of degrees of freedom: 170
Baseline length: 15
Fit started from point 42
Estimated baseline 0.0530034 and standard error 0.000379632
Estimated delta 0.0797495 and standard error 0.00143484
Estimated tau 3.07388 and standard error 0.0906272
RSS per degree of freedom: 0.989537
Probability of observing a larger of equal RSS per DOF under the null hypothesis: 0.524164

**********************************
* Stimulation 2 done
**********************************

**********************************
* Doing now stimulation 3
**********************************
iter  0: baseline = 0.0507, delta = 0.0530, tau = 14.7000, RSS = 10847.6780
iter  1: baseline = 0.0494, delta = 0.0466, tau = 1.1167, RSS = 5844.7928
iter  2: baseline = 0.0560, delta = 0.0376, tau = 3.1071, RSS = 1007.7739
iter  3: baseline = 0.0508, delta = 0.0548, tau = 4.6014, RSS = 210.8745
iter  4: baseline = 0.0499, delta = 0.0560, tau = 4.3709, RSS = 157.6289
iter  5: baseline = 0.0500, delta = 0.0561, tau = 4.3581, RSS = 157.5996
iter  6: baseline = 0.0500, delta = 0.0561, tau = 4.3569, RSS = 157.5996
iter  7: baseline = 0.0500, delta = 0.0561, tau = 4.3568, RSS = 157.5996
iter  8: baseline = 0.0500, delta = 0.0561, tau = 4.3568, RSS = 157.5996
iter  9: baseline = 0.0500, delta = 0.0561, tau = 4.3568, RSS = 157.5996
iter 10: baseline = 0.0500, delta = 0.0561, tau = 4.3568, RSS = 157.5996
iter 11: baseline = 0.0500, delta = 0.0561, tau = 4.3568, RSS = 157.5996
Fitted model Ca = baseline+delta*exp(-(t-t0)/tau)
Summary from method 'trust-region/levenberg-marquardt'
number of iterations: 11
function evaluations: 50
Jacobian evaluations: 0
reason for stopping: small step size
initial RSS = 10847.678001
final   RSS = 157.599555

Number of observation: 163
Number of degrees of freedom: 160
Baseline length: 15
Fit started from point 52
Estimated baseline 0.0499656 and standard error 0.000388917
Estimated delta 0.0561071 and standard error 0.000826757
Estimated tau 4.35681 and standard error 0.130141
RSS per degree of freedom: 0.984997
Probability of observing a larger of equal RSS per DOF under the null hypothesis: 0.538851

**********************************
* Stimulation 3 done
**********************************

******************************************
* Doing tau vs mean kappa_Fura regression *
******************************************
Best fit: tau = 1.43541 + 0.00951986 kappa_Fura
Covariance matrix:
[ +2.05752e-02, -1.00932e-04  
  -1.00932e-04, +5.93942e-07  ]
Total sum of squares (TSS) = 157.149
chisq (Residual sum of squares, RSS) = 4.56232
Probability of observing a larger of equal RSS per DOF under the null hypothesis: 0.0326828
R squared (1-RSS/TSS) = 0.970968
Estimated gamma/v with standard error: 105.044 +/- 8.50376
Estimated kappa_S with standard error (using error propagation): 149.78 +/- 19.3914
kappa_S confidence intervals based on parametric bootstrap
0.95 CI for kappa_S: [104.373,211.581]
0.99 CI for kappa_S: [93.8481,239.592]
******************************************
* tau vs mean kappa_Fura regression done *
******************************************
******************************************
* Doing tau vs min kappa_Fura regression *
******************************************
Best fit: tau = 1.49012 + 0.00965061 kappa_Fura
Covariance matrix:
[ +1.94068e-02, -9.86866e-05  
  -9.86866e-05, +6.09311e-07  ]
Total sum of squares (TSS) = 157.149
chisq (Residual sum of squares, RSS) = 4.2975
Probability of observing a larger of equal RSS per DOF under the null hypothesis: 0.0381685
R squared (1-RSS/TSS) = 0.972653
Estimated gamma/v with standard error: 103.62 +/- 8.38128
Estimated kappa_S with standard error (using error propagation): 153.407 +/- 19.088
kappa_S confidence intervals based on parametric bootstrap
0.95 CI for kappa_S: [108.414,214.659]
0.99 CI for kappa_S: [95.0422,238.853]
******************************************
* tau vs min kappa_Fura regression done  *
******************************************
******************************************
* Doing tau vs max kappa_Fura regression *
******************************************
Best fit: tau = 1.39244 + 0.0094002 kappa_Fura
Covariance matrix:
[ +2.15679e-02, -1.02704e-04  
  -1.02704e-04, +5.81330e-07  ]
Total sum of squares (TSS) = 157.149
chisq (Residual sum of squares, RSS) = 5.14649
Probability of observing a larger of equal RSS per DOF under the null hypothesis: 0.0232934
R squared (1-RSS/TSS) = 0.967251
Estimated gamma/v with standard error: 106.381 +/- 8.62854
Estimated kappa_S with standard error (using error propagation): 147.128 +/- 19.7087
kappa_S confidence intervals based on parametric bootstrap
0.95 CI for kappa_S: [100.924,208.224]
0.99 CI for kappa_S: [88.7097,232.675]
******************************************
* tau vs max kappa_Fura regression done  *
******************************************
</pre>



<p>
We can test it with <code>valgrind</code> as follows (result not shown but its fine):
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org7f1797a">valgrind ./code/aba_ratio -i data_paper/data_beta_escin/DA_121219_E1.h5
</pre>
</div>
</div>
</div>



<div id="outline-container-org36e811a" class="outline-4">
<h4 id="org36e811a"><span class="section-number-4">8.2.3</span> Looking at the results</h4>
<div class="outline-text-4" id="text-8-2-3">
</div>
<div id="outline-container-orgc573e75" class="outline-5">
<h5 id="orgc573e75"><span class="section-number-5">8.2.3.1</span> loading curve</h5>
<div class="outline-text-5" id="text-8-2-3-1">
<p>
The quickest way to get the loading curve is to type:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org88b08d0">gnuplot -persist data_paper/data_beta_escin/DA_121219_E1_aba_loading_curve.gp
</pre>
</div>



<div class="figure">
<p><img src="figs/DA_121219_E1_aba_loading_curve.png" alt="DA_121219_E1_aba_loading_curve.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org6d9666c" class="outline-5">
<h5 id="org6d9666c"><span class="section-number-5">8.2.3.2</span> First stimulation fit</h5>
<div class="outline-text-5" id="text-8-2-3-2">
<p>
The quickest way to get the diagnostic figure is:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org5995b55">gnuplot -persist data_paper/data_beta_escin/DA_121219_E1_aba_RatioFit_s1.gp
</pre>
</div>


<div class="figure">
<p><img src="figs/DA_121219_E1_aba_RatioFit_s1.png" alt="DA_121219_E1_aba_RatioFit_s1.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org4bd5839" class="outline-5">
<h5 id="org4bd5839"><span class="section-number-5">8.2.3.3</span> Second stimulation fit</h5>
<div class="outline-text-5" id="text-8-2-3-3">
<p>
The quickest way to get the diagnostic figure is:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orga18a9a8">gnuplot -persist data_paper/data_beta_escin/DA_121219_E1_aba_RatioFit_s2.gp
</pre>
</div>


<div class="figure">
<p><img src="figs/DA_121219_E1_aba_RatioFit_s2.png" alt="DA_121219_E1_aba_RatioFit_s2.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org22ff036" class="outline-5">
<h5 id="org22ff036"><span class="section-number-5">8.2.3.4</span> Third stimulation fit</h5>
<div class="outline-text-5" id="text-8-2-3-4">
<p>
The quickest way to get the diagnostic figure is:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgbd44a31">gnuplot -persist data_paper/data_beta_escin/DA_121219_E1_aba_RatioFit_s3.gp
</pre>
</div>


<div class="figure">
<p><img src="figs/DA_121219_E1_aba_RatioFit_s3.png" alt="DA_121219_E1_aba_RatioFit_s3.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org8586505" class="outline-5">
<h5 id="org8586505"><span class="section-number-5">8.2.3.5</span> \(\tau\) vs \(\kappa_{Fura}\) regression</h5>
<div class="outline-text-5" id="text-8-2-3-5">
<p>
We get a written summary of the linear regression performed with the mean \(\kappa_F\) value with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org69182a5">head -n 15 data_paper/data_beta_escin/DA_121219_E1_aba_tau_vs_mean_kappa
</pre>
</div>

<pre class="example">
# τ vs mean κ linear regression for data set data_paper/data_beta_escin/DA_121219_E1.h5
# Using stimulation: 1, 2, 3
# Best fit: tau = 1.43541 + 0.00951986 kappa_Fura
# Covariance matrix:
# [ +2.05752e-02, -1.00932e-04  
#   -1.00932e-04, +5.93942e-07  ]
# Total sum of squares (TSS) = 157.149
# chisq (Residual sum of squares, RSS) = 4.56232
# Probability of observing a larger of equal RSS per DOF under the null hypothesis: 0.0326828
# R squared (1-RSS/TSS) = 0.970968
# Estimated gamma/v with standard error: 105.044 +/- 8.50376
# Estimates kappa_S with standard error (using error propagation): 149.78 +/- 19.3914
# kappa_S confidence intervals based on parametric bootstrap
# 0.95 CI for kappa_S: [104.373,211.581]
# 0.99 CI for kappa_S: [93.8481,239.592]
</pre>




<p>
We get the figure with:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orge383543">gnuplot -persist data_paper/data_beta_escin/DA_121219_E1_aba_tau_vs_mean_kappa.gp
</pre>
</div>


<div class="figure">
<p><img src="figs/DA_121219_E1_aba_tau_vs_mean_kappa.png" alt="DA_121219_E1_aba_tau_vs_mean_kappa.png" />
</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Christophe Pouzat</p>
<p class="date">Created: 2019-05-28 mar. 16:50</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
